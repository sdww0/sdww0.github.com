<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Virtio文档阅读笔记(三)具体设备</title>
      <link href="/2022/09/17/virtio%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%B8%89-%E5%85%B7%E4%BD%93%E8%AE%BE%E5%A4%87/"/>
      <url>/2022/09/17/virtio%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%B8%89-%E5%85%B7%E4%BD%93%E8%AE%BE%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p>以下设备的顺序与文档顺序不太一样, 或者不全, 日后会补, 遗留的特征等不会写上来</p><h1 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h1><h2 id="什么是块设备"><a href="#什么是块设备" class="headerlink" title="什么是块设备"></a>什么是块设备</h2><p>在文档中的定义如下: Virtio块设备是一个简单的虚拟块设备, 比如磁盘等, 读取和写入请求被放入在了队列中, 并由设备处理(可能不是顺序处理), 块设备的Device ID为2</p><h2 id="块设备的特征bits"><a href="#块设备的特征bits" class="headerlink" title="块设备的特征bits"></a>块设备的特征bits</h2><table><thead><tr><th>bit</th><th>特证名</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td>VIRTIO_BLK_F_SIZE_MAX</td><td>最大的任何segment的大小放在了<code>size_max</code></td></tr><tr><td>2</td><td>VIRTIO_BLK_F_SEG_MAX</td><td>一个request的最大数量segment放在了<code>seg_max</code></td></tr><tr><td>4</td><td>VIRTIO_BLK_F_GEOMETRY</td><td>Disk-style geometry放在了<code>geometry</code></td></tr><tr><td>5</td><td>VIRTIO_BLK_F_RO</td><td>设备是只读</td></tr><tr><td>6</td><td>VIRTIO_BLK_F_BLK_SIZE</td><td>磁盘的块大小放在了<code>blk_size</code></td></tr><tr><td>9</td><td>VIRTIO_BLK_F_FLUSH</td><td>支持缓存刷新命令</td></tr><tr><td>10</td><td>VIRTIO_BLK_F_TOPOLOGY</td><td>设备利用最佳I&#x2F;O对齐(optimal I&#x2F;O alignment)导出消息</td></tr><tr><td>11</td><td>VIRTIO_BLK_F_CONFIG_WCE</td><td>设备的缓存可以在writeback和writethrough模式之间循环切换</td></tr><tr><td>13</td><td>VIRTIO_BLK_F_DISCARD</td><td>设备可以支持discard(丢弃)命令, 最多可以discard的sector数量放在了<code>max_discard_sectors</code>以及最多可以discard的segment数量放在了<code>max_discard_seg</code></td></tr><tr><td>14</td><td>VIRTIO_BLK_F_WRITE_ZEROES</td><td>设备可以支持全写0命令, 最多可以全写0的sector数量放在了<code>max_discard_sectors</code>以及最多可以全写0的segment数量放在了<code>max_discard_seg</code></td></tr></tbody></table><h2 id="设备配置空间"><a href="#设备配置空间" class="headerlink" title="设备配置空间"></a>设备配置空间</h2><p>这里直接放个文档中的截图, le64代表小端64bit, le32代表小端32bit, le16代表小端16bit, u8代表8bit</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140147996.png" alt="image-20220917192134946"></p><p>其中<code>capacity</code>代表一个设备能支持的最大容量, 单位为512byte的扇区, 这一字段总是存在的, 其他的需要特征是否启用, 配置空间中的<code>max_discard_secotrs</code>, <code>discard_sector_alignment</code> 以及<code>max_write_zeroes_sectors</code>的单位均为512-byte.</p><h2 id="设备初始化"><a href="#设备初始化" class="headerlink" title="设备初始化"></a>设备初始化</h2><ol><li>设备的大小可以从<code>capacity</code>中获取到</li><li>如果有VIRTIO_BLK_F_BLK_SIZE特征, 则<code>blk_size</code>可以用来决定最佳的扇区大小,这不会影响协议中其他的单位(均为512bytes).</li><li>如果有VIRTIO_BLK_F_RO特征, 则所有的写操作都会失效</li><li>如果有VIRTIO_BLK_F_TOPOLOGY特征, 则驱动可以使用<code>topology</code>结构体可以用来决定物理块大小和最佳的I&#x2F;O长度, 同样不会影响协议中其他的单位</li><li>如果有VIRTIO_BLK_F_CONFIG_WCE特征, 则可以通过读取或者写入writeback来获取&#x2F;修改缓存模式, 0代表writethrough模式, 1代表writeback模式</li><li>如果有VIRTIO_BLK_F_DISCARD特征, 则驱动可以使用<code>max_discard_sectors</code>和<code>max_discard_seg</code>来获得最大可以discard的扇区以及segments, 当基于对齐拆分请求时, 操作系统可以使用<code>discard_sector_alignment</code></li><li>如果有VIRTIO_BLK_F_WRITE_ZEROES特征, 则驱动可以使用<code>max_write_zeroes_sectors</code>和<code>max_write_zeroes_seg</code>来获得最大可以写入0的扇区以及segments</li></ol><h3 id="驱动注意事项"><a href="#驱动注意事项" class="headerlink" title="驱动注意事项"></a>驱动注意事项</h3><ol><li>驱动不能请求VIRTIO_BLK_F_FLUSH特征如果驱动不能发送VIRTIO_BLK_F_FLUSH命令</li><li>如果VIRTIO_BLK_F_CONFIG_WCE以及VIRTIO_BLK_F_FLUSH都没有仲裁, 那么驱动应该假设使用了缓存使用了writethrough模式, 如果前者没有仲裁, 后者由, 则驱动应该假设缓存使用了writeback模式</li><li>在FEATURES_OK之前, 驱动不能读取<code>writeback</code>字段</li></ol><h2 id="设备操作"><a href="#设备操作" class="headerlink" title="设备操作"></a>设备操作</h2><p>驱动使用virtqueue来请求服务, 每个请求大致结构如下:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140147979.png" alt="image-20220917193826918"></p><p>其中的type只能取下面其中之一的值:</p><table><thead><tr><th>值</th><th>名</th><th>解释</th></tr></thead><tbody><tr><td>0</td><td>VIRTIO_BLK_T_IN</td><td>请求读取块设备中的数据</td></tr><tr><td>1</td><td>VIRTIO_BLK_T_OUT</td><td>请求写入数据到块设备中</td></tr><tr><td>4</td><td>VIRTIO_BLK_T_FLUSH</td><td>刷新指令(缓存?可能是)</td></tr><tr><td>11</td><td>VIRTIO_BLK_T_DISCARD</td><td>discard指令</td></tr><tr><td>13</td><td>VIRTIO_BLK_T_WRITE_ZEROS</td><td>write zeroes指令</td></tr></tbody></table><p><code>sector</code>字段代表从哪个位置读取或者写入数据, 单位为512 bytes, 如果不是IN或者OUT则要设为0, discard或者write zeroes指令需要更多的字段, 这些字段被放在了data中, 字段的结构如下:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140147728.png" alt="image-20220917194736992"></p><p>其中<code>sector</code>与IN或者OUT代表的意义一样, <code>num_sectors</code>代表操作多少个扇区, <code>unmap</code>只用在write zeros命令, 允许设备discard一个特定的区域, 前提是后续读取返回0</p><p>最终读取的状态由设备写入, 他们的值以及代表的意义为:</p><ul><li>VIRTIO_BLK_S_OK 0: 成功</li><li>VIRTIO_BLK_S_IOERR 1: 设备或者驱动出错</li><li>VIRTIO_BLK_S_UNSUPP: 设备不支持的请求</li></ul>]]></content>
      
      
      <categories>
          
          <category> Virtio文档阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Virtio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCI+Express体系结构导读笔记(二)-MSI及MSI-X</title>
      <link href="/2022/09/16/PCI+Express%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AF%BC%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%BA%8C-MSI%E5%8F%8AMSI-X/"/>
      <url>/2022/09/16/PCI+Express%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AF%BC%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%BA%8C-MSI%E5%8F%8AMSI-X/</url>
      
        <content type="html"><![CDATA[<h1 id="MSI及MSI-X中断机制"><a href="#MSI及MSI-X中断机制" class="headerlink" title="MSI及MSI-X中断机制"></a>MSI及MSI-X中断机制</h1><h2 id="为什么提出这两个概念"><a href="#为什么提出这两个概念" class="headerlink" title="为什么提出这两个概念"></a>为什么提出这两个概念</h2><p>在<a href="https://zhuanlan.zhihu.com/p/407100254">这一篇</a>中讲的原因为: MSI&#x2F;MSI-X机制的引入解决了传统Line-based Interrupt机制的限制, 包括:</p><ul><li>无需经过I&#x2F;O APIC转发中断，直接通过PCI&#x2F;PCIe Memory Write Transaction向CPU发送中断，效率更高</li><li>每个PCI Function可以支持分配多个中断向量，满足同一个设备有多个不同中断请求的需要</li><li>当分配多个中断向量给同1个PCI Function时，提供按中断向量进行屏蔽的功能，更为灵活</li></ul><p>在PCI中, MSI&#x2F;MSI-X为可选功能, PCIe必须要修支持64位的MSI或者MSI-X, 一个PCIe可以同时支持 INT#x&#x2F;MSI&#x2F;MSI-X, 但驱动只用启动其中一个, MSI&#x2F;MSI-X以Capability的形式存在于PCIe中</p><h2 id="MSI-x2F-MSI-X-Capability结构"><a href="#MSI-x2F-MSI-X-Capability结构" class="headerlink" title="MSI&#x2F;MSI-X Capability结构"></a>MSI&#x2F;MSI-X Capability结构</h2><h3 id="MSI结构"><a href="#MSI结构" class="headerlink" title="MSI结构"></a>MSI结构</h3><p>MSI的结构可以由四种方式组成, 分别为:</p><ul><li>32位的Message结构</li><li>64位的Message结构</li><li>32位带中断的Masking结构</li><li>64位带中断的Masking结构</li></ul><p>MSI报文可以使用32位或者64位的地址, 并且可以使用Masking(掩码)机制使能或禁止某个中断, MSI Capability结构如下:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140146573.png" alt="image-20220916123928435"></p><p>MSI的Capability ID值为0x05, PCIe设备中每一个Capability结构都有唯一的ID号, Next Pointer指向下一个Capability, 其余各字段的解释如下:</p><ul><li><p>Message Control: 存放当前PCIe设备使用MSI进行中断请求的状态域控制信息, 每一位代表的意思如下表:</p><table><thead><tr><th>Bits</th><th>定义</th><th>描述</th></tr></thead><tbody><tr><td>15:9</td><td>Reserved</td><td>保留,始终为0</td></tr><tr><td>8</td><td>Per-vector Masking Capable</td><td>为1, 则为带中断的Masking, 设备初始化时设置</td></tr><tr><td>7</td><td>64 bit Address Capable</td><td>为1, 则支持64位的地质结构, 为0则支持32位, 设备初始化时设置</td></tr><tr><td>6:4</td><td>Multiple Message Enable</td><td>表示软件分配给当前PCIe设备的中断向量数目, 驱动根据Multiple Message Capable确定这个值, 资源不紧张则相等, 资源紧张可能小于</td></tr><tr><td>3:1</td><td>Multiple Message Capable</td><td>驱动只读, 表示当前PCIe设备可以使用几个中断向量号, 0~5分别代表使用1, 2, 4, 8, 16, 32个中断向量,其余值保留</td></tr><tr><td>0</td><td>MSI Enable</td><td>MSI中断机制使能位, 为1且MSI-X的Enable为0, 则使用MSI中断机制, 此时Legacy中断机制被禁止. 如果两个中断机制都禁止, 则使用INT#x中断消息报文发出&#x2F;结束中断请求</td></tr></tbody></table></li><li><p>Message Address: 存放MSI存储器写事务的目的地址的低32位, 1~0位始终为0, 不使用</p></li><li><p>Message Upper Address: 如果为64位, 则该值为MSI存储器写事务的目的地址的高32位</p></li><li><p>Message Data: 存放MSI报文使用的数据, 不同处理器对该字段的规则不同, 如果Multiple Message Enable不为0(支持多个中断请求), 则PCIe设备可以通过改变该字段的低位数据以发送不同的中断请求</p></li><li><p>Mask Bits: 由32位组成, 每一位代表一种中断请求, 为1代表该中断被屏蔽, 0代表启用</p></li><li><p>Pnending Bits: 对于驱动是只读位, 当Mask Bits对应位为1(屏蔽中断)时, 如果 PCIe 设备需要发送对应的中断请求时，Pending Bits 字段的对应位将被 PCIe 设备的内部逻辑置1, 如果Mask bits改写为0后, PCIe设备会发送MSI报文向处理器提交中断请求, 将对应位清0, 在驱动开发中, 有时需要联合使用Mask Bits与Pending Bits防止处理器丢弃中断请求.</p></li></ul><h3 id="MSI-X结构"><a href="#MSI-X结构" class="headerlink" title="MSI-X结构"></a>MSI-X结构</h3><p>引入MSI-X的主要原因是因为不需要中断向量号连续, 并且MSI-X支持更多的中断请求, MSI-X主要使用MSI-X Table存放该设备使用的所有 Message Address和 Message Data字段, 这个表格存放在BAR空间中, MSI-X结构如下:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140146209.png" alt="image-20220916130244988"></p><p>MSI-X的Capability ID为0x11, Next Pointer指向下一个Capability地址, Message Control各bit定义如下:</p><table><thead><tr><th>Bits</th><th>定义</th><th>描述</th></tr></thead><tbody><tr><td>15</td><td>MSI-X Enable</td><td>使能位, 是否启用MSI-X</td></tr><tr><td>14</td><td>Function Mask</td><td>为1, 则所有中断被屏蔽, 为0, 则启用所有中断</td></tr><tr><td>10:0</td><td>Table Size</td><td>代表MSI-X Table的大小, 只读</td></tr></tbody></table><ul><li>Table BIR(BAR Indicator Register), 该字段存放的是MSI-X Table在哪个BAR空间, 总共有3位, 0<del>5分别对应BAR0</del>5</li><li>Table Offset, 存放的是MSI-X Table在对应BAR空间中的偏移</li><li>PBA(Pending Bit Array) BIR, 该字段存放Pending Table在哪个BAR空间, 总共有3位, 0<del>5分别对应BAR0</del>5</li><li>PBA Offset,存放的是Pending Table在对应BAR空间中的偏移</li></ul><h4 id="MSI-X-Table"><a href="#MSI-X-Table" class="headerlink" title="MSI-X Table"></a>MSI-X Table</h4><p>组成结构如下(DWORD代表32bit), 每一个Entry与一个中断请求对应:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140146703.png" alt="image-20220916130927818"></p><ul><li>Msg Addr: MSI-X 存储器写事务的目的地址的低 32 位, 31:2有效, 可读写, 1:0始终为0, 只读,</li><li>Msg Upper Addr: 该字段可读写，存放 MSI-X 存储器写事务的目的地址的高 32 位</li><li>Msg Data: 可读写, 存放MSI-X报文使用的数据</li><li>Vector Control: 只有第0位有效, 其他位保留, 为1 则代表不能使用该Entry提交中断请求, 为0代表可以, 复位时为0, 使用方法与MSI的Mask为类似</li></ul><h4 id="Pending-Table"><a href="#Pending-Table" class="headerlink" title="Pending Table"></a>Pending Table</h4><p>组成如下(QWORD代表64bit):</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140146256.png" alt="image-20220916131337971"></p><p>与MSI机制的Pending bits类似, 每一个Entry由64位组成, 一个bit对应一个中断, 在此不多赘述</p><h2 id="x86中处理MSI-X中断请求"><a href="#x86中处理MSI-X中断请求" class="headerlink" title="x86中处理MSI-X中断请求"></a>x86中处理MSI-X中断请求</h2><p>PCIe设备发出MSI-X中断请求的方法与发出MSI中断请求的方法类似, 都是像 Message Address所在的地址写Message Data字段包含的数据, 只不过Message Address和Message Data在MSI-X中放在了BAR空间. x86需要设置MSI-X Capability结构指向的Message Address和Message Data, 并使能MSI-X Enable位</p><h3 id="Message-Address与Message-Data"><a href="#Message-Address与Message-Data" class="headerlink" title="Message Address与Message Data"></a>Message Address与Message Data</h3><p>x86处理器中, PCIe设备使用的Message Address与Message Data字段与PowerPC处理器(IBM开发的)不同</p><h4 id="Message-Address"><a href="#Message-Address" class="headerlink" title="Message Address"></a>Message Address</h4><p>在x86中, Message Address字段仍然保留PCI总线域的地址, 格式如下:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140146395.png" alt="image-20220916164450743"></p><ul><li>31-20, 存放FSB Interrupts存储器空间的基地址, 值位0xFEE</li><li>19-12, 保存目标CPU的ID号, 如果CPU的ID与该字段相等, 则目标CPU将会接受这个Interrupt Message</li><li>11-4, 保留</li><li>3(Redirection Hint Indication), 如果为0, 则表示Interrupt Message将直接发向与Destination ID字段相同的CPU, 如果为1, 则启用中断转发功能</li><li>2(Destination Mode), 表示在传递优先级低的中断请求时, Destination ID是否被翻译为Logical或者Physical APIC ID, x86处理器中APIC ID有三种模式, 分别为 Physical, Logical和Cluster ID模式</li><li>1-0, 为0</li></ul><p>如果RH为1, DM为0, 则Destination ID使用Physical模式, 如果RH为1, DM为1, 则使用Logical模式, 如果RH为0, 则忽略DM</p><h4 id="Message-Data"><a href="#Message-Data" class="headerlink" title="Message Data"></a>Message Data</h4><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140147908.png" alt="image-20220916165500867"></p><ul><li><p>31-16, 保留</p></li><li><p>15-14, 触发模式, 为0时使用边沿触发方式申请中断, 为1时使用低电平触发方式申请中断, 为2时使用高电平触发方式申请中断</p></li><li><p>13-11, 保留</p></li><li><p>10-8, 表示如何处理来自PCIe设备的中断请求, 如下:</p></li><li><table><thead><tr><th>值</th><th align="left">模式</th><th>说明</th></tr></thead><tbody><tr><td>0b000</td><td align="left">Fixed Mode</td><td>中断请求将被Destination ID字段指定的CPU处理</td></tr><tr><td>0b001</td><td align="left">Lowest Priority</td><td>中短请求将被优先级最低的CPU处理</td></tr><tr><td>0b010</td><td align="left">SMI</td><td>必须使用边沿触发, Vector必须为0, 中断请求将被Destination ID字段指定的CPU处理</td></tr><tr><td>0b100</td><td align="left">NMI</td><td>必须使用边沿触发, Vector和Trigger字段被忽略, 中断请求将被Destination ID字段指定的CPU处理</td></tr><tr><td>0b101</td><td align="left">INIT</td><td>Vector和Trigger字段被忽略, 中断请求将被Destination ID字段指定的CPU处理</td></tr><tr><td>0b111</td><td align="left">INTR</td><td>使用INTR信号传递中断请求并且使用边沿触发, MSI中断信息首先传递给中断控制器, 然后再通过INTR信号传递给CPU</td></tr></tbody></table></li><li><p>7-0, Vector, 当使用了Fixed Mode或者 Lowest Priority模式时, 如果Vector字段有效, CPU收到中断请求后会使用Vector字段指定的中断向量处理这些中断请求, 当为其他值时, Vector字段无效</p></li></ul><h3 id="驱动程序初始化PCIe设备的MSI"><a href="#驱动程序初始化PCIe设备的MSI" class="headerlink" title="驱动程序初始化PCIe设备的MSI"></a>驱动程序初始化PCIe设备的MSI</h3><p>如果PCIe设备支持MSI机制, 则驱动程序需要做以下事情:</p><ol><li>设置设备MSI Capability结构的Message Address和Message Data字段, 如果设备支持64位地址空间, 则还需要设置Upper Address字段</li><li>置MSI Capabilities中的MSI Enable位有效, 使能MSI机制</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://book.douban.com/subject/4728656/">PCI Express 体系结构导读</a></li><li><a href="https://zhuanlan.zhihu.com/p/407100254">PCIe中断机制(4): MSI和MSI-X)</a></li><li><a href="https://cloud.tencent.com/developer/article/1661649">PCIe系列第八讲、MSI和MSI-X中断机制</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> PCI+Express体系结构导读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCI </tag>
            
            <tag> PCIe </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCI+Express体系结构导读笔记(一)-基础介绍</title>
      <link href="/2022/09/14/PCI+Express%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AF%BC%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/09/14/PCI+Express%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%AF%BC%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>只注重架构以及软件的实现, 其余内部的具体信号还有其他的引脚不会记录</p><h1 id="PCI的结构"><a href="#PCI的结构" class="headerlink" title="PCI的结构"></a>PCI的结构</h1><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140144808.png" alt="image-20220914095228114"></p><p>如图所示, PCI总线的相关模块包括:</p><ul><li>Host主桥</li><li>PCI总线</li><li>PCI桥</li><li>PCI设备</li></ul><p>整个PCI架构以一个树状结构呈现, Host主桥用于连接CPU与PCI设备, PCI桥用于拓展PCI设备(树中的非叶子节点), PCI总线代表树中的枝, PCI设备则代表树中的所有节点(下面的定义中, PCI桥也是PCI设备的一部分,只是他是用于拓展其他PCI设备用的).</p><h2 id="Host主桥"><a href="#Host主桥" class="headerlink" title="Host主桥"></a>Host主桥</h2><p>Host主桥的主要功能有:</p><ul><li>隔离处理器系统的存储器域与PCI总线域, 一个Host主桥对应一个PCI总线域</li><li>管理PCI总线域</li><li>完成处理器与PCI设备之间的数据交换</li></ul><h2 id="PCI总线"><a href="#PCI总线" class="headerlink" title="PCI总线"></a>PCI总线</h2><p>PCI总线由HOST主桥以及PCI桥进行管理, 用来连接各种设备</p><h2 id="PCI设备"><a href="#PCI设备" class="headerlink" title="PCI设备"></a>PCI设备</h2><p>PCI总线中一共有三种设备:</p><ul><li>PCI主设备, 可以通过总线仲裁获得PCI总线的使用权, 主动发出请求</li><li>PCI从设备, 只能被动接受来自HOST主桥或者其他PCI设备的读写请求</li><li>桥设备, 用于管理下游的PCI总线, 即为PCI桥</li></ul><p>PCI总线规范中将PCI主从设备统称为PCI Agent设备, 比如常见的网卡, 显卡, 声卡.</p><h1 id="PCI设备配置"><a href="#PCI设备配置" class="headerlink" title="PCI设备配置"></a>PCI设备配置</h1><h2 id="PCI设备配置空间"><a href="#PCI设备配置空间" class="headerlink" title="PCI设备配置空间"></a>PCI设备配置空间</h2><p>PCI设备头部的64个字节为固定的, 所有PCI设备必须支持, 具体定义如下图:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140144060.png" alt="PCI设备配置空间"></p><ol><li>Device ID和 Vendor ID: Vendor ID代表PCI设备的生产厂商, Device ID代表厂商生产的具体设备</li><li>Status: 大多数为只读, 保存PCI设备状态</li><li>Command: PCI设备的命令寄存器, 初始化设为0</li><li>Class Code和 Revision ID: 只读寄存器, 其中后者记录的是PCI设备的版本号, 可以认为是Device ID的拓展, Class Code貌似在其他情况下也是用于区分唯一设备的</li><li>Header Type: 只读, 由8位组成:<ul><li>第7位代表PCI设备为多功能设备, 0为单功能设备</li><li>第6~0为标识当前配置空间的类型, 0代表为PCI Agent设备的配置空间, 1代表PCI桥的配置空间(两者不太一样), 2代表Cardbus桥片的配置空间</li></ul></li><li>Latency Timer: 用于控制PCI设备占用PCI总线的时间, 当PCI设备获得总线使用权后, 这个寄存器会递减, 归零后取消使用权</li><li>Cache Line Size: 记录处理器使用的Cache行长. 在 PCI 总线中和 Cache 相关的总线事务，如 存储器写并无效和 Cache 多行读等总线事务需要使用这个寄存器, 由软件写入, 硬件逻辑使用</li><li>Subsystem ID 和 Subsystem Vendor ID: 与Device ID和Vendor ID类似, 记录PCI设备的生产厂商和设备名称</li><li>Expansion ROM base address: 用于存储在运行操作系统前, 进行基本初始化的程序代码基地址(存储在ROM中)</li><li>Capabilities Pointer: PCI可选, PCIe必须支持, 用于存储Capabilities寄存器组的基地址, PCI设备使用Capabilities 寄存器组存放一些与PCI设备相关的扩展配置信息</li><li>Interrupt Line(右下角, 被logo挡住了): 软件对PCI设备配置时写入, 记录当前PCI设备使用的中断向量号, 设备驱动程序可以通过该寄存器注册服务到操作系统中</li><li>Interrupt Pin: 保存PCI设备使用的中断引脚, 1-4 分别使用 INTA#, INTB#, INTC#, INTD#引脚, 不使用则设为0</li><li>Base Address Register(BAR) 0~5: 保存PCI设备使用的地址空间基地址, 保存的是设备在<strong>PCI总线域</strong>中的地址, PCI设备复位后, 每个PCI设备在BAR中描述自己需要占用多少地址空间, 这段空间是IO空间还是存储器空间, 软件之后可以通过向VAR寄存器写入全1, 读取该寄存器, 清空特殊编码值, 取反并加1得到需要占用的地址空间大小.</li><li>Capabilities Pointer: 如果status中启用了capabilities, 代表这个设备使用了64~256字节之间的拓展配置空间, pointer指向的是下一个capability的偏移(在这个地址空间内)</li></ol><p>以下图片分别为Memory和IO下的BAR寄存器结构:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140144520.jpeg" alt="Memory"></p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140145621.png" alt="IO"></p><p>status各字段含义:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140145692.png" alt="img"></p><h2 id="PCI桥配置空间"><a href="#PCI桥配置空间" class="headerlink" title="PCI桥配置空间"></a>PCI桥配置空间</h2><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140145768.jpeg" alt="img"></p><p>与PCI设备配置空间差不多, 对于BAR0<del>1, 这两组的含义与上面的一致, 只是这两组寄存器为可选寄存器, 大多数PCI桥不存在私有寄存器, 操作系统也不需要为PCI桥提供专门的驱动程序, 如果PCI桥不存在私有空间, 则BAR0</del>1被设为0, 其他特有寄存器如下:</p><ul><li>Subordinate Bus Number、Secondary Bus Number和Primary Bus Number: 第一个代表桥下面管理的编号最大的PCI总线, 第二个代表最小的PCI总线号, 最后一个代表PCI桥上游的总线号, 一个PCI桥能管理的PCI总线号范围即为Secondary Bus Number~Subordinate Bus Number, 他们三者初始化时均为0, 可提供过这个来判断是否被配置过</li><li>I&#x2F;O Limit和I&#x2F;O Base: 用于存放PCI子树中所有设备使用的IO地址空间集合的基地址(后者)和大小(前者)</li><li>Memory Limit和Memory Base: 用于存放PCI子树中所有设备使用的存储空间集合的基地址(后者)和大小(前者)</li><li>Prefetchable Memory Limit和Prefetchable Memory Base: 如果管理的PCI设备支持预读, 则需要从PCI桥的可预读空间中获取地址空间. 这两个寄存器分别存放PCI设备使用的可预读存储器空间的基地址和大小.</li></ul><h2 id="PCI总线树初始化"><a href="#PCI总线树初始化" class="headerlink" title="PCI总线树初始化"></a>PCI总线树初始化</h2><p>PCI总线树中, 有多少个PCI桥(包括HOST主桥), 就有多少条总线. 软件遍历时需要对PCI总线进行编号, 初始化PCI桥的Primary、Secondary和Subordinate Bus Number寄存器, 下图是DFS后, 总线号分配情况以及桥上总线相关寄存器的初始化情况:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140145153.png" alt="img"></p><h2 id="配置PCI设备"><a href="#配置PCI设备" class="headerlink" title="配置PCI设备"></a>配置PCI设备</h2><p>x86定义了两个IO端口寄存器, 分别为CONFIG_ADDRESS和CONFIG_DATA寄存器, 地址分别为0xCF8和0xCFC, 利用这两个IO端口即可访问PCI设备的配置空间, 其中CONFIG_ADDRESS寄存器存放PCI设备的ID号, CONFIG_DATA寄存器存放配置的读写数据. CONFIG_ADDRESS寄存器结构如下:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140145951.png" alt="img"></p><ul><li>Enable bit: 该位为1时, 对CONFIG_DATA寄存器进行读写会引发PCI总线的配置周期</li><li>Bus Number: PCI设备的总线号</li><li>Device Number: PCI设备的设备号</li><li>Function Number: PCI设备的功能号</li><li>Register Number: PCI设备的寄存器号</li></ul><p>当CONFIG_ADDRESS中的Enable为1时, 对CONFIG_DATA寄存器进行的IO读写访问会由Host主桥转化为PCI配置读写总线事务, 然后发送到PCI总线上, 之后会根据CONFIG_ADDRESS中的总线号, 设备号, 功能号, 寄存器号完成对特定设备的指定寄存器读写</p><blockquote><p>通过总线号, 设备号, 功能号能找到一个特定的PCI设备, 相当于一个特定PCI设备的身份证号, 寄存器号则代表配置空间寄存器偏移量, 比如0就代表不偏移, 4就代表偏移4bytes</p></blockquote><p>PCIe 扩展了配置空间的大小, 最大到4K, 具体如下:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140145672.png" alt="img"></p><ul><li>0~3Fh位基本配置空间大小, 就是上面说的64字节</li><li>PCI Express Capability Structure ，PCI可选支持，PCIe支持</li><li>PCI Express Extended Capability Structure，PCI不支持，PCIe支持</li></ul><p>为了访问&gt;256字节的空间, 支持通过MMIO的方式访问配置空间, 但为了兼容性, 保留了IO访问方式, 最后附上PCIe设备的空间:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140145914.jpeg" alt="img"></p><h2 id="PCI设备读写"><a href="#PCI设备读写" class="headerlink" title="PCI设备读写"></a>PCI设备读写</h2><p>配置好PCI设备的BAR寄存器后, 即可通过BAR空间地址对PCI设备进行读写操作, 具体如下:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140145083.png" alt="img"></p><h1 id="参考文档或链接"><a href="#参考文档或链接" class="headerlink" title="参考文档或链接"></a>参考文档或链接</h1><ol><li>PCI Express体系结构导读</li><li><a href="https://zhuanlan.zhihu.com/p/26244141">深入PCI与PCIe之二：软件篇</a></li><li><a href="https://blog.csdn.net/hx_op/article/details/104029386">PCI入门</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> PCI+Express体系结构导读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCI </tag>
            
            <tag> PCIe </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Virtio文档阅读笔记(二)传输形式</title>
      <link href="/2022/09/13/virtio%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E4%BC%A0%E8%BE%93%E5%BD%A2%E5%BC%8F/"/>
      <url>/2022/09/13/virtio%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E4%BC%A0%E8%BE%93%E5%BD%A2%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Virtio的传输形式"><a href="#Virtio的传输形式" class="headerlink" title="Virtio的传输形式"></a>Virtio的传输形式</h1><p>Virtio可以使用各种不同的总线, 因此标准分为Virtio通用部分和总线专用部分</p><h2 id="基于PCI总线的Virtio"><a href="#基于PCI总线的Virtio" class="headerlink" title="基于PCI总线的Virtio"></a>基于PCI总线的Virtio</h2><h3 id="发现PCI设备"><a href="#发现PCI设备" class="headerlink" title="发现PCI设备"></a>发现PCI设备</h3><p>任何PCI供应商ID为0x1AF4且PCI设备ID为0x1000到0x107F(包括1000和107F)的PCI设备都是virtio设备, 这个范围内(0x1000-0x107F)的值标识是哪个virtio设备, PCI设备ID与Virtio设备计算方式为PCI设备ID &#x3D; 0x1040+Virtio设备ID, 此外, 根据设备类型, 设备可能使用过渡的PCI设备ID范围0x1000-0x103F. PCI的子设备供应商ID和PCI子设备ID可以反应PCI供应商和设备ID(毕竟原来的被占用了)</p><table><thead><tr><th>暂时PCI设备ID</th><th>Virtio设备类型</th></tr></thead><tbody><tr><td>0x1000</td><td>网络设备</td></tr><tr><td>0x1001</td><td>块设备</td></tr><tr><td>0x1002</td><td>内存膨胀(memory ballooning)</td></tr><tr><td>0x1003</td><td>控制台</td></tr><tr><td>0x1004</td><td>SCSI host</td></tr><tr><td>0x1005</td><td>entropy source</td></tr><tr><td>0x1009</td><td>9P transport</td></tr></tbody></table><p>一个例子: 网络设备的Virtio设备ID为1, 则他的PCI设备ID为0x1041(0x1040+1)或者过渡PCI设备ID 0x1000.</p><h3 id="PCI设备布局"><a href="#PCI设备布局" class="headerlink" title="PCI设备布局"></a>PCI设备布局</h3><p>设备通过IO和&#x2F;或者内存区域进行配置, 具体由Virtio Structure PCI Capabilities规定. 所有的64bit, 32bit, 16bit大小的空间为小端模式, 64bit被认为是两个32bit组成的, 有高32bit和低32bit之分, 驱动程序必须使用8bit读写命令去读写8bit大小的空间, 同样适用于16和32bit, 对于64bit, 驱动程序可以独立访问字段的高32位和低32位</p><h4 id="Virtio-Structure-PCI-Capabilities"><a href="#Virtio-Structure-PCI-Capabilities" class="headerlink" title="Virtio Structure PCI Capabilities"></a>Virtio Structure PCI Capabilities</h4><p>一个virtio设备配置布局包含以下结构:</p><ul><li>通用配置 Common configuration</li><li>通知 Notifications</li><li>ISR状态 ISR Status</li><li>设备指定的配置(可选) Device-specific configuration (optional)</li><li>PCI配置访问 PCI configuration access</li></ul><p>每一个结构可以通过function中的Base Address register(BAR)映射, 或者通过访问特殊的VIRTIO_PCI_CAP_PCI_CFG字段. 每个结构体的位置由一个设备PCI配置空间能力(Capability)列表中的一个供应商PCI能力指定. Virtio结构使用小端格式, 除非另有说明, 否则对于驱动程序来讲所有字段均为只读:</p><ul><li><p>cap_vndr u8: capability类型</p></li><li><p>cap_next u8: 下一个capability再pci配置空间的位置</p></li><li><p>cap_len u8: 表示这个capability的长度</p></li><li><p>cfg_type u8: 含有以下取值(前面的标号即为大小), 将virtio-pci的capability细分为几类:</p><ol><li>VIRTIO_PCI_CAP_COMMON_CFG: 通用配置</li><li>VIRTIO_PCI_CAP_NOTIFY_CFG: 通知</li><li>VIRTIO_PCI_CAP_ISR_CFG: ISR Access</li><li>VIRTIO_PCI_CAP_DEVICE_CFG: 设备特定的配置</li><li>VIRTIO_PCI_CAP_PCI_CFG: PCI配置访问</li></ol></li><li><p>bar u8: 表示是哪一个BAR被用来将结构体映射到内存或者IO空间</p></li><li><p>padding u8*3(数组): 貌似没啥用, 用来填充到64bit的</p></li><li><p>offset 小端32bit: 这个结构体在BAR中的位移</p></li><li><p>length 小端32bit: 这个结构体的大小</p></li></ul><h4 id="Virtio通用配置空间"><a href="#Virtio通用配置空间" class="headerlink" title="Virtio通用配置空间"></a>Virtio通用配置空间</h4><p>cfg_type为1, 可以根据bar和offset找到他, 包含以下字段(介绍中就以顺序介绍了, 不把变量名打上去了):</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140143810.png" alt="code-snapshot-1663157105477"></p><table><thead><tr><th>变量名</th><th>作用</th></tr></thead><tbody><tr><td>device_feature_select</td><td>选择下一个变量内的包含哪些bit,0代表选择feature bit 0<del>31, 1代表选择feature bit 32</del>63</td></tr><tr><td>device_feature</td><td>设备有哪些特征</td></tr><tr><td>driver_feature_select</td><td>选择下一个变量内的包含哪些bit,0代表选择feature bit 0<del>31, 1代表选择feature bit 32</del>63</td></tr><tr><td>driver_feature</td><td>驱动程序接受设备的哪些特征</td></tr><tr><td>msix_config</td><td>驱动程序设置MSI-X的配置向量(在文档中也成为config_msix_vector),注意是MSIX的entry number</td></tr><tr><td>num_queues</td><td>设备支持的最大数量virtqueue</td></tr><tr><td>device_status</td><td>设备状态, 写入0以重启设备</td></tr><tr><td>config_generation</td><td>配置计数器? 每次有配置改变时,这个也会跟着改变</td></tr><tr><td>queue_select</td><td>驱动程序设置下面域说明的是哪个virtqueue</td></tr><tr><td>queue_size</td><td>队列大小, 设备重置时代表设备能支持的最大队列大小, 0则代表不能使用该队列</td></tr><tr><td>queue_msix_vector</td><td>驱动程序使用这个去指定MSI-X的队列向量,注意是MSIX的entry number</td></tr><tr><td>queue_enable</td><td>队列是否启用, 1-启用, 0-不启用</td></tr><tr><td>queue_notify_off</td><td>驱动程序可以读取这个来计算得到这个队列在通知结构体中的偏移量</td></tr><tr><td>queue_desc</td><td>驱动程序写入, 用于表示描述符区域的起始物理地址</td></tr><tr><td>queue_driver</td><td>驱动程序写入, 用于表示驱动区域的起始物理地址</td></tr><tr><td>queue_device</td><td>驱动程序写入, 用于表示设备区域的起始物理地址</td></tr></tbody></table><p>有一些字段文档中会有详细说明</p><h4 id="通知结构布局"><a href="#通知结构布局" class="headerlink" title="通知结构布局"></a>通知结构布局</h4><p>cfg_type为2, 在原来的cap后面加一个notify_off_multiplier, 小端32bit, 可以通过计算: <code>cap.offset + queue_notify_off * notify_off_multiplier</code>找到一个virtqueue在BAR空间中的位置, 其中cap.offset是该capability的offset, queue_notify_off为通用配置空间中的queue_notify_off, notify_off_multiplier就是上面字段的值</p><h4 id="ISR状态"><a href="#ISR状态" class="headerlink" title="ISR状态"></a>ISR状态</h4><p>cfg_type为3, 包含一个8bit的ISR状态用于INT#x中断处理(查看他的具体值得知这个貌似是存在了BAR空间), 以下是bit的具体说明:</p><ul><li>bit0, Queue Interrupt</li><li>bit1, Device Configuration Interrupt</li><li>bit2+, Reserved</li></ul><p>如果MSI-X capability启用, 检测到队列中断时, 驱动程序不能访问ISR状态</p><h4 id="设备特定的配置"><a href="#设备特定的配置" class="headerlink" title="设备特定的配置"></a>设备特定的配置</h4><p>cfg_type为4, 依赖于每个具体的设备的配置</p><h4 id="PCI配置访问"><a href="#PCI配置访问" class="headerlink" title="PCI配置访问"></a>PCI配置访问</h4><p>cfg_type为5, 在原来的cap后面加一个pci_cfg_data, 8bit*4的数组, 对于驱动来讲这个数组可读可写, 这个配置相当于提供了一个第二种访问以上区域的方法, 具体流程为:</p><ul><li>写入要访问的BAR到cap.bar</li><li>写入1,2或者4代表长度到cap.length</li><li>写入在BAR中的偏移量到cap.offset</li></ul><p>这样pci_cfg_data就会提供位于cap.bar, 偏移量为cap.offset, cap.length大小的窗口.</p><h3 id="初始化以及之后的操作"><a href="#初始化以及之后的操作" class="headerlink" title="初始化以及之后的操作"></a>初始化以及之后的操作</h3><p>第一步自然是扫描PCI capabilities list, 获得配置空间信息, 不多赘述了</p><h4 id="配置MSI-X-Vector"><a href="#配置MSI-X-Vector" class="headerlink" title="配置MSI-X Vector"></a>配置MSI-X Vector</h4><p>如果有MSI-X Capability并且启用了, 则config_msix_vector和queue_msix_vector存储在MSI-X Table中有效的entry number(0~0x7FF), 用来代表配置改变中断和队列中断, 如果需要禁用某个终端, 则写入一个特殊的值:0xffff</p><h4 id="配置Virtqueue"><a href="#配置Virtqueue" class="headerlink" title="配置Virtqueue"></a>配置Virtqueue</h4><p>驱动需要对每个virtqueue做以下事情:</p><ol><li>写入virtqueue的index(第一个virtqueue为0)到queue_select中</li><li>读取queue_size, 获得该queue的大小, 如果为0则代表该virtqueue不存在</li><li>(可选)选择一个小于virtqueue大小的值然后写入queue_size中</li><li>分配并清空一个virtqueue的描述符表, 可用和已用环在连续物理内存的地方</li><li>(可选)如果有MSI-X Capability并且启用了, 选择一个vector用于请求virtqueue事件触发的中断, 写入MSI-X的entry number到queue_msix_vector中并读取他, 如果成功了则为之前的值, 如果失败则返回NO_VECTOR(0xffff)</li></ol><h4 id="可用缓冲通知"><a href="#可用缓冲通知" class="headerlink" title="可用缓冲通知"></a>可用缓冲通知</h4><p>如果VIRTIO_F_NOTIFICATION_DATA没启用, 则驱动需要通过写入16bit的virtqueue索引到Queue Notify Address(参考通知结构布局一节计算这个地址的位置)来发送一个可用缓冲通知. 如果启用, 则需要写入32bit小端的值到Queue Notify Address中:</p><ul><li>31bit: next_wrap: 如果有VIRTIO_F_RING_PACKED,则 代表指向下一个可用的描述符的wrap counter, 如果没有则代表这个是可用索引的最高位bit(第15bit, 以0开始)</li><li>30~16bit: next_off: 在一个ring种下一个可用的ring entry的值, 如果没有VIRTIO_F_RING_PACKED则代表是可用索引的低15位(0~14), 如果有则代表下一个可用的描述符再描述符ring中的oofset</li><li>15~0bit: vqn: 要通知的Virtqueue数字</li></ul><h4 id="已用缓冲通知"><a href="#已用缓冲通知" class="headerlink" title="已用缓冲通知"></a>已用缓冲通知</h4><p>如果需要触发一个可用缓冲通知, 则设备将会做以下操作:</p><ul><li>MSI-X 未启用:<ol><li>设置ISR状态域的最低位</li><li>发送合适的PCI中断</li></ol></li><li>MSI-X 启用:<ol><li>如果 queue_msix_vector 不是NO_VECTOR, 则请求对应的MSI-X中断报文(queue_msix_vector的值为MSI-X Table entry number)</li></ol></li></ul><h4 id="设备配置更改通知"><a href="#设备配置更改通知" class="headerlink" title="设备配置更改通知"></a>设备配置更改通知</h4><p>有一些Virtio PCI设备会更改设备配置, 具体为设备指定的配置空间(cfg_type为4), 这种情况下:</p><ul><li>MSI-X 未启用:<ol><li>设置ISR状态域的第二个最低位</li><li>发送合适的PCI中断</li></ol></li><li>MSI-X 启用:<ol><li>如果 config_msix_vector不是NO_VECTOR, 则请求对应的MSI-X中断报文(config_msix_vector的值为MSI-X Table entry number)</li></ol></li></ul><p>一次中断可能代表一个以上已经被使用的virtqueue或者&#x2F;和配置空间被修改.</p><h4 id="驱动如何处理中断"><a href="#驱动如何处理中断" class="headerlink" title="驱动如何处理中断"></a>驱动如何处理中断</h4><ul><li>MSI-X 未启用:<ul><li>读取ISR 状态域, 设为0</li><li>如果最低位被设置, 则查找所有的virtqueues, 查看设备操作的结果并进行反应</li><li>如果第二个最低位被设置, 则重新分析配置空间</li></ul></li><li>MSI-X 启用:<ul><li>查找所有被映射到该MSI-X vector的virtqueues, 查看设备操作的结果并进行反应</li><li>如果MSI-X vector等于config_msix_vector, 重新分析配置空间</li></ul></li></ul><h1 id="参考文档及链接"><a href="#参考文档及链接" class="headerlink" title="参考文档及链接"></a>参考文档及链接</h1><p>文档链接:</p><ol><li><a href="https://www.oasis-open.org/standard/virtio-v1-1/">oasis</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Virtio文档阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Virtio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Virtio文档阅读笔记(一)基础设备</title>
      <link href="/2022/09/13/virtio%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/09/13/virtio%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><ol><li>文档中的特殊说明比如驱动程序必须要干啥, 设备必须要干啥没总结了, 按着规矩来就好, 如果发现出问题了可以上文档里翻翻</li><li>有一些自认为多余的没加上来, 防止看的有点绕.</li></ol><h1 id="Virtio基本设施"><a href="#Virtio基本设施" class="headerlink" title="Virtio基本设施"></a>Virtio基本设施</h1><p>每个virtio设备通过一个特定的方法被发现(具体为PCI, MMIO, 通道IO), 每个设备包含以下的部分</p><ul><li>设备状态字段(Device status field)</li><li>特征位 (Feature bits)</li><li>通知 (Notification)</li><li>设备配置空间 (Device Configuration space)</li><li>一个或多个虚拟队列 (one or more virtqueues)</li></ul><h2 id="设备状态字段"><a href="#设备状态字段" class="headerlink" title="设备状态字段"></a>设备状态字段</h2><p>包含该设备的状态:</p><ul><li>ACKNOWLEDGE(1): 操作系统发现了这个设备, 认为这是个有效的virtio设备</li><li>DRIVER(2): 操作系统知道怎么驱动该设备</li><li>FAILED(128): 由于某种原因, 操作系统放弃驱动该设备</li><li>FEATURES_OK(8): 驱动程序确认了它理解的所有特征, 特征协商达成一致</li><li>DRIVER_OK(4): 驱动程序加载完成, 可以驱动该设备了</li><li>DEVICE_NEEDS_RESET(64): 设备出错, 需要重置</li></ul><h2 id="特征位"><a href="#特征位" class="headerlink" title="特征位"></a>特征位</h2><p>每个Virtio设备需提供他所支持的特征, 在设备初始化阶段, 驱动程序读取这个数据并且要告诉设备它接受的特征子集(设备支持的特征集子集), 重新进行特征协商(上面的这个过程)的唯一方法就是重置设备. 特征位具体意义如下:</p><ul><li>0-23: 特定设备可以使用的特征位</li><li>24-37: 预留给队列和特征协商机制的特征位</li><li>38-…: 给未来其他用途</li></ul><p>手册给了个例子: 对于一个网络设备来讲, 如果feature bit为0, 则代表这个设备支持包的checksum检验</p><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>通知分为三种类型:</p><ul><li>配置空间修改通知 (configuration change notification)</li><li>可用缓冲区通知 (available buffer notification)</li><li>已用缓冲区通知 (used buffer notification)</li></ul><p>其中第一个和第三个由设备发出, 驱动程序接受, 配置空间修改通知代表设备配置空间被修改过了, 已用缓冲区通知代表该通知指定的一个virtqueue中的缓冲区可能已经被使用, 可用缓冲区通知代表该通知指定的一个virtqueue中的缓冲区可能可以使用. (这一部分理解有点绕..不一定是对的)</p><p>不同的通知的语义需要依赖于传输的实现以及其他方面, 大多数使用中断实现设备发送给驱动程序的通知.</p><h2 id="设备配置空间"><a href="#设备配置空间" class="headerlink" title="设备配置空间"></a>设备配置空间</h2><p>设备配置空间通常用于很少更改或初始化时需要设置的设备参数, 设备的特征位包含配置空间是否存在的bit, 可以通过在特征位的末尾添加新的bit来扩展配置空间, 设备配置空间对于多个byte的配置采用的是小端模式, 驱动程序不能假设大于32bit的读取是原子性的.</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>Virtio的大数据传输机制被称为虚拟队列(Virtqueue), 每个设备可以有零个或者多个虚拟队列. 每个队列占用2或多个4K的物理页, 驱动程序与设备之间通信的流程如下:</p><ol><li>驱动程序通过向队列中添加可用缓冲区, 即向设备发送可用缓冲区通知</li><li>设备处理请求, 完成时向队列中添加已用缓冲区, 即向驱动程序发送已用缓冲区通知</li></ol><p>每个虚拟队列包含最多三个部分:</p><ul><li>描述符区域, 用于描述缓冲</li><li>驱动程序区域, 驱动程序提供给设备的额外数据</li><li>设备区域, 设备提供给驱动程序的额外数据</li></ul><p>一共支持两种类型的虚拟队列, 分别为Split Virtqueue以及 Packed Virtqueue</p><h2 id="Split-Virtqueue"><a href="#Split-Virtqueue" class="headerlink" title="Split Virtqueue"></a>Split Virtqueue</h2><p>这个为1.0版本以及更早版本支持的的虚拟队列, 它将虚拟队列拆分成不同的部分, 每个部分要么驱动程序可写, 要么设备可写, 不能同时两边可写, 如果缓冲区被标记为可用或者已被使用, 则需要更新一个部分中的多个部分和&#x2F;或者位置. 每个队列包含一个16-bit大小的队列大小参数, 表示队列的总长度, 每个虚拟队列包含以下三个部分:</p><ul><li>描述符表(Descriptor Table): IO传输请求信息（描述符）的数组，每个描述符都是对某buffer 的address&#x2F;length描述。buffer中包含IO传输请求的命令&#x2F;数据&#x2F;返回结果等。</li><li>可用环(Available Ring): 记录了描述符表中被驱动程序更新的描述符的索引集合，需要后端的设备进行读取并完成相关I&#x2F;O操作</li><li>已用环(Used Ring): 记录了描述符表中被设备更新的描述符的索引集合，需要前端的驱动程序进行读取并完成对I&#x2F;O操作结果的响应</li></ul><p>每个部分都由连续的物理内存块组成, 并且有不同的对齐需求, 驱动程序必须保证每一个部分的第一个byte的物理地址是下述表中对齐值的倍数:</p><table><thead><tr><th>虚拟队列部分</th><th>对齐(bytes)</th><th>大小</th></tr></thead><tbody><tr><td>描述符表</td><td>16</td><td>16*队列大小</td></tr><tr><td>可用环</td><td>2</td><td>(6+2)*队列大小</td></tr><tr><td>已用环</td><td>4</td><td>(6+8)*队列大小</td></tr></tbody></table><p>队列大小代表的是支持的最大缓冲区数量, 并且总是2^n, 最大的大小为32768(2^15). 这三者使用方法如下: 当驱动程序需要发送一个缓冲区到设备时, 它会填充描述符表中的一个插槽, 并将描述符索引写入可用环中, 然后通知设备. 当设备处理完缓冲区内容时, 设备将描述符索引写入已用环, 并发送已用缓冲区通知.</p><h3 id="描述符表"><a href="#描述符表" class="headerlink" title="描述符表"></a>描述符表</h3><p>描述符表用来存指向IO传输请求的信息, 即是驱动程序与设备进行交互的缓冲区, 每一个描述符由以下部分组成:</p><ul><li>addr 小端64bit, 存储buffer的物理地址</li><li>len 小端32bit, 存储buffer的长度</li><li>flag 小端16bit, 存储为flag, 具体有(括弧中为值, 应该转化为bit, 比如4代表是bit2(0起始)):<ol><li>NEXT(1): 有下一个描述符表</li><li>WRITE(2): 是否为可写, 不然就为可读(可写或可读,不能两者都有)</li><li>INDIRECT(4): 这个buffer包含一列表的buffer描述符</li></ol></li><li>next 小端16bit, 存储下一个描述符表的索引, 如果flag为next</li></ul><p>buffer所在的物理地址空间需要操作系统在初始化或者运行时分配好, 后续由驱动程序在里面填写IO传输相关的命令&#x2F;数据, 或者是设备返回IO操作的结果. 多个描述符 (IO操作命令, IO操作数据块, IO操作的返回结果)形成的描述符链可以表示一个完整的IO操作请求.</p><p>INDIRECT代表的意思是buffer中存的是一堆描述符表索引, addr同样代表的是该addr的地址, len同样是长度, 只不过里面的内容为(len&#x2F;16)个描述符索引.</p><h3 id="可用环"><a href="#可用环" class="headerlink" title="可用环"></a>可用环</h3><p>每个可用环由以下部分组成:</p><ul><li>flags 小端16bit, 包含一个NO_INTERRUPT bit(bit0)</li><li>idx 小端16bit</li><li>ring 小端16bit, 总共有queue_size个ring</li><li>used_event 小端16bit(只有当VIRTOIO_F_EVNET_IDX启用时才会有,特征EVENT_IDX)</li></ul><p>驱动程序用可用环来输入缓存到设备中, 每一个ring代表一个描述符的头, 只可以被驱动程序写入, 被设备读出, idx代表驱动程序将在环中放置下一个描述符条目的位置(队列大小的模), 这一位从0开始, 逐步增加 (相当于一个环形队列,尾部后又跳到头部)</p><p>看手册中, used_event使用方法为:</p><ul><li>没有EVENT_IDX, 则flag必须为0或者1(启用或者不启用中断, 在这里又称为通知notification), 如果为1, 则不启用中断, 如果为0, 则启动中断</li><li>有EVENT_IDX, 则flag可以忽略, 驱动必须要设置flag为0, 之后驱动用used_event来告诉设备是否要通知(中断), 如果used_event等于idx, 则设备会发送通知(中断), 如果不相等, 则不会发送中断</li></ul><h3 id="已用环"><a href="#已用环" class="headerlink" title="已用环"></a>已用环</h3><p>每个已用环由以下部分组成:</p><ul><li>flags 小端16bit, 包含一个NO_NOTIFY(bit0)</li><li>idx 小端16bit</li><li>ring struct virtq_used_elem 内部包含一个小端32bit的id, 小端32bit的len, 分别代表已用描述符索引的起始位置以及描述符链的总长度, 采用32bit的id文档中说明是因为填充原因, 总共有queue_size个ring</li><li>avail_event 小端16bit, 只有当EVNET_IDX特征开启时才会有</li></ul><p>其中flags和idx以及avail_event和可用环差不多功能, ring部分将16bit扩展成了64bit, 包含一个id(跟可用环的ring差不多意思)以及一个len(代表buffer大小), 文档中对于len的描述为, 方便驱动程序将要写入的位置清0, 防止数据泄露, 比如上一个程序在这里写了些数据, 有一些没有清零直接设为了buffer内容.</p><p>对于Virtqueue这一部分文档中给了似乎是linux的代码, <a href="https://docs.oasis-open.org/virtio/virtio/v1.1/cs01/listings/virtio_queue.h">链接</a>.</p><h2 id="Packed-Virtqueue"><a href="#Packed-Virtqueue" class="headerlink" title="Packed Virtqueue"></a>Packed Virtqueue</h2><p>这一部分等有时间了写一下</p><h1 id="设备初始化以及操作"><a href="#设备初始化以及操作" class="headerlink" title="设备初始化以及操作"></a>设备初始化以及操作</h1><h2 id="设备初始化"><a href="#设备初始化" class="headerlink" title="设备初始化"></a>设备初始化</h2><p>驱动程序要遵循以下的步骤初始化一个设备:</p><ol><li>重置设备</li><li>设置ACKNOWLEDGE状态</li><li>设置DRIVER状态</li><li>读取设备特征bit, 写入操作系统支持的特征bit, 在这一步驱动可能要读取(不能写入) 设备特定的配置空间区查看驱动自己能不能支持这个设备</li><li>设置FEATURES_OK, 这一步之后, 驱动程序不能接受新的特征bit</li><li>一直重复读取设备状态去确保FEATURES_OK被设置成功了, 要不然设备可能不能支驱动程序设置的特征(很简单的意思, 问他接受不接受)</li><li>进行特定设备的配置, 包括发现设备的virtqueue, 读取或者写入设备的Virtio配置空间</li><li>设置DRIVER_OK状态, 这时候代表设备已经可以使用了</li></ol><p>如果任何步骤除了不可恢复的问题, 则驱动程序需要设置FAILED状态, 代表驱动放弃了这个设备, 驱动不能发送可用缓冲区通知直到状态为DRIVER_OK.</p><h2 id="设备操作"><a href="#设备操作" class="headerlink" title="设备操作"></a>设备操作</h2><p>操作设备时, 设备配置空间中的每个字段可以由驱动程序或者设备更改, 当设备更改配置时, 会以通知的形式告诉驱动程序. 设备通过设置DEVICE_NEEDS_RESET来触发配置空间修改通知</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol><li><a href="https://www.oasis-open.org/standard/virtio-v1-1/">oasis</a></li><li><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter9/2device-driver-2.html">rCore</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Virtio文档阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Virtio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Rust改写riscv-pk总结</title>
      <link href="/2022/09/04/%E7%94%A8Rust%E6%94%B9%E5%86%99riscv-pk%E6%80%BB%E7%BB%93/"/>
      <url>/2022/09/04/%E7%94%A8Rust%E6%94%B9%E5%86%99riscv-pk%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h2><p> 最近闲来无事, 便想总结一下暑假进行的用Rust改写riscv-pk这个练手项目, 主要是为了熟悉一下rCore以及Rust, 也学会了用objdump来反汇编一个二进制文件进行debug, 目前看来除了rCore的文件系统以及一些驱动基本都熟悉了一遍, 因为riscv-pk的文件系统是直接交由宿主机完成, 它只是一个代理作用, 熟悉rCore的同时也了解了riscv-pk的pk部分, 与现在在看的x86_64的内存空间分布感觉差不多.</p><p> 总的来讲改写起来还是蛮有趣的, 主要有成就感的点有几个, 一个是当os输出hello world的时候(蛮简单的), 以及虚拟内存成功跑起来, 还有一个就是跑user-mode的elf文件, 并且syscall陷入trap, 最后一个点成就感比较明显. 但这一次改写只是搭建了一个框架, 实现了user-mode程序的hello world, 没有实现其他的syscall, 这一部分还是需要未来慢慢熟悉, 慢慢实现.</p><p> 最后补一句: rCore无论是教程还是代码都蛮不错, 建议去看看, 附:</p><ul><li><a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/">rCore教程地址</a></li><li><a href="https://github.com/rcore-os/rCore-Tutorial-v3">rCore GitHub地址</a></li></ul><h2 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h2><p> 这一次总结不说明代码的内部细节, 只是想总结一下改写过程遇到的事情, 由于改写已经经过了一个月了, 所以有一些可能记得不是很清楚, 见谅.</p><h3 id="起步阶段"><a href="#起步阶段" class="headerlink" title="起步阶段"></a>起步阶段</h3><p> 起步阶段大致就是需要看懂riscv-pk他是如何启动的, 毕竟proxy-kernel的环境和真正的操作系统还是有点区别, 他把bootloader和操作系统相当于嵌在一起了, 这一部分没啥好说的, 由于proxy-kernel他的系统调用都跑到宿主机上了, 所以实现起来比较简单, hello world大概一周还是两周就跑起来了.</p><h3 id="中间阶段"><a href="#中间阶段" class="headerlink" title="中间阶段"></a>中间阶段</h3><p> 这一阶段比较难… 由于对rCore的多任务以及虚拟内存还是不太熟悉, 所以需要同时看两边代码, 一边看一边学习, 在这期间还遇到了一个无语的问题, 就是proxy kernel他要将PTE中的Access bit置为1才能访问, 不然他就不知道这个虚拟地址..这个问题卡了我一周, 尝试了各种方式, 包括把proxy kernel的映射方式改到rCore中, 把rCore改写成支持大页模式, 改static变量的内存地址, 最后把proxy kernel简历页表的那些bit弄过来才发现要Access bit, 他对RWX权限定义的bit和正常的bit还不一样..</p><p> 虚拟内存结束了就是多任务以及任务的地址空间布局了, 这一部分还好, proxy kernel并不支持多任务系统, 他的页表也是用户和内核共用的, 只不过内核映射到了高位地址, 用户使用低位地址, 这一部分我就直接用了rCore的映射方式, 第一点是改写static变量的地址在Rust中貌似比较烦..proxy kernel他用c语言直接设置offset地址就好了, rCore一对一映射不用改地址比较舒服. 第二点是rCore现成的就摆在那了(懒得改了).</p><h3 id="结束阶段"><a href="#结束阶段" class="headerlink" title="结束阶段"></a>结束阶段</h3><p> 最后一步就是trap以及文件系统了, 这一部分最简单了, 对于trap, 在解决了前面的问题后, 只需要看懂proxy kernel以及rCore他们的trap汇编和其他代码就好了, 当然最后采用的是rCore的方式, 毕竟地址空间布局用的人家的, 合情合理(hh). 文件系统把proxy kernel那一套移植一下就完成了, 毕竟是直接给宿主机发系统调用, 不用写太多.</p><p> 最后整合在一起, 用户态二进制文件我直接用的rCore中的user编译出来的hello world程序了, 毕竟他用的系统调用较少, 我直接编译一个c文件发现他用了贼多系统调用..还是rCore的那个简单, 一个write, 一个exit解决了.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 这一篇比较短, 没有太多代码细节, 毕竟是练手项目, 没啥好说的, 最后写完的感觉就是rCore以及pk的缝合体hh, 不过缝合的过程中对他们的具体实现也理解的蛮多, 收获应该有以下几点吧:</p><ul><li>对rCore的代码理解的更深了, 具体为虚拟内存, trap, 多任务, 地址空间分布.</li><li>对于Rust的引用那些的使用的更熟了一点</li><li>会通过看反汇编文件, 一步步跑汇编指令来debug了, 虽然riscv-pk还不是用gdb debug的, 但一些功能是gdb的.</li><li>pk的地址空间分布与最近在看的x86_64地址空间分布类似, 当初还一头雾水, 不知道为啥要这样搞, x86_64之后才了解到大家貌似都是这么搞得hh.</li></ul><p> 改写后的代码还没整理, 包括去除一些不必要的文件等事情还没做, 只是把Rust编译的warning给弄掉了, 因此就没弄成公开状态.</p>]]></content>
      
      
      <categories>
          
          <category> RISCV学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISCV </tag>
            
            <tag> Rust </tag>
            
            <tag> 总结 </tag>
            
            <tag> Proxy Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x86_64-寄存器详解</title>
      <link href="/2022/08/18/x86-64-%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/08/18/x86-64-%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>这一篇的寄存器来自于<code>Rust-x86_64库总结</code>,讲解在registers下的一些寄存器, 随时更新</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><table><thead><tr><th>寄存器名</th><th>作用</th><th>谁保存</th></tr></thead><tbody><tr><td>%rax</td><td>返回值</td><td>-</td></tr><tr><td>%rbx</td><td></td><td>被调用者</td></tr><tr><td>%rcx</td><td>参数4</td><td>调用者</td></tr><tr><td>%rdx</td><td>参数3</td><td>调用者</td></tr><tr><td>%rsi</td><td>参数2</td><td>调用者</td></tr><tr><td>%rdi</td><td>参数1</td><td>调用者</td></tr><tr><td>%rbp</td><td></td><td>被调用者</td></tr><tr><td>%rsp</td><td>栈顶(指针)</td><td>-</td></tr><tr><td>%r8</td><td>参数5</td><td>调用者</td></tr><tr><td>%r9</td><td>参数6</td><td>调用者</td></tr><tr><td>%r10</td><td></td><td>调用者</td></tr><tr><td>%r11</td><td></td><td>调用者</td></tr><tr><td>%r12</td><td></td><td>被调用者</td></tr><tr><td>%r13</td><td></td><td>被调用者</td></tr><tr><td>%r14</td><td></td><td>被调用者</td></tr><tr><td>%r15</td><td></td><td>被调用者</td></tr></tbody></table><blockquote><p>还有一个指令寄存器RIP, 不知道放哪就放这了</p></blockquote><h3 id="Control-Registers"><a href="#Control-Registers" class="headerlink" title="Control Registers"></a>Control Registers</h3><p>各个寄存器大致的说明:</p><ol><li>CR0: 当前处理器运行的控制标志</li><li>CR2: 发生页面错误时的线性地址</li><li>CR3: 最高级页表的地址(与RISCV中的satp作用差不多)</li><li>CR4: 包含处理器扩展功能的标志位</li></ol><p>图片:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140143749.png" alt="img"></p><h4 id="CR0"><a href="#CR0" class="headerlink" title="CR0"></a>CR0</h4><table><thead><tr><th>位名</th><th>全称</th><th>作用(是否的话除特殊说明否则视为bool)</th></tr></thead><tbody><tr><td>PE</td><td>Protected mode Enable</td><td>是否启用保护模式</td></tr><tr><td>MP</td><td>Monitor coProcessor</td><td>与TS一起使用, 一起决定是否 触发一个 #NE 错误(?)</td></tr><tr><td>EM</td><td>Emulate coProcessor</td><td>是否能使用 x87与MMX 指令, 如果为1, 则不能使用, 并触发 #NE 错误</td></tr><tr><td>TS</td><td>Task Switched</td><td>当任务切换时自动置为1</td></tr><tr><td>ET</td><td>Extension Type</td><td>是否支持 387DX 数学协处理器(Rust注释中这个一般在最近发行的处理器都有)</td></tr><tr><td>NE</td><td>Numeric Error</td><td>Enables the native (internal) error reporting mechanism for x87 FPU errors.(注释)</td></tr><tr><td>WP</td><td>Write Protect</td><td>决定S-mode(RING2?)能否写入只能读的page</td></tr><tr><td>AM</td><td>Alignment mask</td><td>用户模式自动对齐</td></tr><tr><td>NW</td><td>Not Write through</td><td>一般设为0, 在老的CPU用来控制 write-back&#x2F;write-through 缓存策略</td></tr><tr><td>CD</td><td>Cache Disable</td><td>关闭一些处理器的缓存</td></tr><tr><td>PG</td><td>PaGing</td><td>是否开启分页模式, 如果为1则PE bit也需要置为1</td></tr></tbody></table><blockquote><p><strong>Cache写机制:</strong>(Write-back与Write-through)</p><ol><li>Write through: CPU向cache写入数据时, 同时向memory写入数据, 使得数据保持一致</li><li>Write back: CPU更新cache时, 只将cache标记一下(可能是设为Dirty?), 只有当cache需要更新数据时才更新memory</li></ol></blockquote><h4 id="CR3"><a href="#CR3" class="headerlink" title="CR3"></a>CR3</h4><ul><li>PWT(Page-Level Write through) bit: 设置页表是否使用Write through策略, 0则为Write back</li><li>PCD(Page-Level Cache Disable) bit: 是否关闭页表缓存</li></ul><h4 id="CR4"><a href="#CR4" class="headerlink" title="CR4"></a>CR4</h4><p>PS:</p><ol><li>有一些图片内没有, 除了第15位为空, 剩下的可以直接顺序往下数</li><li>FS_GS Base我拆开了, 他的位为16, 没参考官方的, 都是从x86 64中的注释以及名字看的</li><li>由于位实在有点多, CR4主要是标志一些扩展或者特定的处理器功能是否支持, 所以暂时不写作用了..</li><li>一些位名的全称为猜的, 看全称能体会意思就好了</li></ol><table><thead><tr><th>位名(有一些图片内没有, 直接写Rust中的全称了)</th><th>全称</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>VME</td><td>Virtual 8086 Mode Extensions</td><td></td><td></td></tr><tr><td>PVI</td><td>Protected mode Virtual Interrupts</td><td></td><td></td></tr><tr><td>TSD</td><td>TimeStamp Disable</td><td></td><td></td></tr><tr><td>DE</td><td>Debugging Extensions</td><td></td><td></td></tr><tr><td>PSE</td><td>Page Size Extension</td><td></td><td></td></tr><tr><td>PAE</td><td>Physical Address Extension</td><td></td><td></td></tr><tr><td>MCE</td><td>Machine Check Exception</td><td></td><td></td></tr><tr><td>PGE</td><td>Page Global Enable</td><td></td><td></td></tr><tr><td>PCE</td><td>Performance monitor Counter Enable</td><td></td><td></td></tr><tr><td>OSFXSR</td><td>OSFXSR</td><td></td><td></td></tr><tr><td>OSXMMECPT</td><td>OSXMMEXCPT</td><td></td><td></td></tr><tr><td>UMIP</td><td>User Mode Instruction Prevention</td><td></td><td></td></tr><tr><td>L5_Paging</td><td>L5_Paging</td><td></td><td>Intel only</td></tr><tr><td>VMXE</td><td>Virtual Machine eXtEnsions</td><td></td><td>Intel only</td></tr><tr><td>SMXE</td><td>Safe Mode eXtEnsions</td><td></td><td>Intel only</td></tr><tr><td>FS_GS Base</td><td>FS_GS Base</td><td></td><td></td></tr><tr><td>PCIDE</td><td>Process Context IDentifiers Enable</td><td></td><td></td></tr><tr><td>OSXSAVE</td><td>OSXSAVE</td><td></td><td></td></tr><tr><td>KL</td><td>Key locker</td><td></td><td>Intel only</td></tr><tr><td>SMEP</td><td>Supervisor Mode Execution Protection</td><td></td><td></td></tr><tr><td>SMAP</td><td>Supervisor Mode Access Prevention</td><td></td><td></td></tr><tr><td>PK</td><td>Protection Key user</td><td></td><td></td></tr><tr><td>CFE</td><td>Control Flow Enforcement</td><td></td><td></td></tr><tr><td>PKE</td><td>Protection Key Supervisor</td><td></td><td>Intel only</td></tr></tbody></table><h3 id="Model-Specific-Registers"><a href="#Model-Specific-Registers" class="headerlink" title="Model Specific Registers"></a>Model Specific Registers</h3><p>看了下intel的 volume4..貌似每个处理器的MSR还不一样.. 我直接写一下库中的寄存器以及全称&#x2F;作用吧</p><table><thead><tr><th>名</th><th>全称&#x2F;作用</th></tr></thead><tbody><tr><td>Efer</td><td>Extended Feature Enable Register</td></tr><tr><td>FsBase</td><td>[FS].Base Model Specific Register</td></tr><tr><td>GsBase</td><td>[GS].Base Model Specific Register</td></tr><tr><td>KernelGsBase</td><td>KernelGsBase Model Specific Register.</td></tr><tr><td>Star</td><td>系统调用寄存器</td></tr><tr><td>LStar</td><td>系统调用寄存器</td></tr><tr><td>SFMask</td><td>系统调用寄存器</td></tr><tr><td>UCet</td><td>U-mode CET配置</td></tr><tr><td>SCet</td><td>S-mode CET 配置</td></tr></tbody></table><h4 id="Efer-flags"><a href="#Efer-flags" class="headerlink" title="Efer flags"></a>Efer flags</h4><p>Efer 寄存器内各个位所代表意义</p><table><thead><tr><th>全称</th><th>作用</th><th>位</th></tr></thead><tbody><tr><td>System Call Extensions</td><td>启用syscall, sysret指令</td><td>0</td></tr><tr><td>Long Mode Enable</td><td>启动长模式</td><td>8</td></tr><tr><td>Long Mode Active</td><td>表明长模式已经启用</td><td>10</td></tr><tr><td>No Execute Enable</td><td>不能执行的页面保护特性</td><td>11</td></tr><tr><td>Secure Virtual Machine Enable</td><td>启用SVM扩展</td><td>12</td></tr><tr><td>Long Mode Segment Limit Enable</td><td>在64位中启用分段长度限制?</td><td>13</td></tr><tr><td>Fast fxsave fxrstor</td><td>64位中将fxsave以及fxrstor指令执行的更快</td><td>14</td></tr><tr><td>Translation Cache Extension</td><td>改变invlpg指令如何操作TLB entries</td><td>15</td></tr></tbody></table><h4 id="Cet-flags"><a href="#Cet-flags" class="headerlink" title="Cet flags"></a>Cet flags</h4><table><thead><tr><th>全称</th><th>作用</th><th>位</th></tr></thead><tbody><tr><td>SS Enable</td><td>启用影子栈(shadow stack)</td><td>0</td></tr><tr><td>SS Write Enable</td><td>启用 WRSS{D,Q}W指令</td><td>1</td></tr><tr><td>IBT Enable</td><td>启用indirect branch tracking</td><td>2</td></tr><tr><td>IBT Legacy Enable</td><td>启用indirect branch tracking 兼容模式(legacy treatment, 我感觉意思是兼容模式)</td><td>3</td></tr><tr><td>IBT no track enable</td><td>启用no-track opcode for indirect branch tracking</td><td>4</td></tr><tr><td>IBT Legacy Suppress Enable</td><td>禁用 CET Suppression</td><td>5</td></tr><tr><td>IBT Suppress Eanble</td><td>启用 Suppression</td><td>10</td></tr><tr><td>IBT Tracked</td><td>只读</td><td>11</td></tr></tbody></table><h4 id="系统调用寄存器"><a href="#系统调用寄存器" class="headerlink" title="系统调用寄存器"></a>系统调用寄存器</h4><h5 id="Lstar"><a href="#Lstar" class="headerlink" title="Lstar"></a>Lstar</h5><p>用于存储syscall的入口函数</p><h5 id="Star"><a href="#Star" class="headerlink" title="Star"></a>Star</h5><p>未知, rCore x86中设为了(2 &lt;&lt; 3 &lt;&lt; 48) | (1 &lt;&lt; 3 &lt;&lt; 32)</p><h5 id="SFMask"><a href="#SFMask" class="headerlink" title="SFMask"></a>SFMask</h5><p>应该是启用syscall的mask, rCore中设为了0x47700,注释为 TF|DF|IF|IOPL|AC|NT, 日后找到了位的意思会补充</p>]]></content>
      
      
      <categories>
          
          <category> x86学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 寄存器 </tag>
            
            <tag> x86_64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust-x86_64库</title>
      <link href="/2022/08/18/Rust-x86-64%E5%BA%93/"/>
      <url>/2022/08/18/Rust-x86-64%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>最近在学x86_64的操作系统, blog os中用到了x86_64这个库, 看了一下里面蛮多东西都已经写好了, 可以直接用, 所以总结一下(由于里面的寄存器或者指令等可能不会用到,所以这篇会跟RISCV CSV详解那一张一样随时更新), 总结的同时也能了解一下x86的一些东西</p><p>首先列出来每个rs文件的作用, 之后会细讲里面的一些东西:</p><h2 id="根目录"><a href="#根目录" class="headerlink" title="根目录"></a>根目录</h2><table><thead><tr><th>文件名</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>addr.rs</td><td>包含物理地址以及虚拟地址的结构体</td><td></td></tr><tr><td>lib.rs</td><td>库的lib, 包含一个特权级的enum</td><td></td></tr></tbody></table><h2 id="structures"><a href="#structures" class="headerlink" title="structures"></a>structures</h2><table><thead><tr><th>文件名</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>gdt.rs</td><td>二级中断表, 指定每个中断入口函数后load启用</td><td>GlobalDescriptorTable</td></tr><tr><td>idt.rs</td><td>一级中断表, 指定每个中断入口函数后load启用</td><td>InterruptDescriptorTable</td></tr><tr><td>mod.rs</td><td>mod</td><td></td></tr><tr><td>port.rs</td><td>两个trait, 用于读写IO端口</td><td>提供给instructions包用的</td></tr><tr><td>tss.rs</td><td>用于描述一个TaskStateSegment</td><td>64位与32位有点区别,参见下面的表格与图片</td></tr></tbody></table><p><strong>64位:</strong></p><table><thead><tr><th>Field</th><th>Type</th></tr></thead><tbody><tr><td>(reserved)</td><td><code>u32</code></td></tr><tr><td>Privilege Stack Table</td><td><code>[u64; 3]</code></td></tr><tr><td>(reserved)</td><td><code>u64</code></td></tr><tr><td>Interrupt Stack Table</td><td><code>[u64; 7]</code></td></tr><tr><td>(reserved)</td><td><code>u64</code></td></tr><tr><td>(reserved)</td><td><code>u16</code></td></tr><tr><td>I&#x2F;O Map Base Address</td><td><code>u16</code></td></tr></tbody></table><p><strong>32位:</strong></p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140142922.jpeg" alt="img"></p><h3 id="paging"><a href="#paging" class="headerlink" title="paging"></a>paging</h3><table><thead><tr><th>文件名</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>frame_alloc.rs</td><td>一个trait, FrameAllocator</td><td>用于分配一个页的物理内存</td></tr><tr><td>frame.rs</td><td>用于描述物理页,包含PhysFrame等结构体</td><td></td></tr><tr><td>mod.rs</td><td>mod</td><td></td></tr><tr><td>page_table.rs</td><td>用于描述一个页表, PageTable(N个PTE)</td><td>还包含PTE的结构体以及index等</td></tr><tr><td>page.rs</td><td>用于描述一个虚拟页</td><td>包含大页等</td></tr></tbody></table><h4 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h4><p>此包下包含一些已经实现的页表, 不用自己来具体设置如何映射, 只需要传入一些参数调用里面的一些方法即可</p><table><thead><tr><th>文件名</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>mapped_page_table.rs</td><td>一个页表的实现, 只需要实现一个虚拟地址如何和物理地址转换的函数</td><td>其他具体的页表基础</td></tr><tr><td>mod.rs</td><td>包含一些trait, translate等</td><td></td></tr><tr><td>offset_page_table.rs</td><td>位移页表</td><td></td></tr><tr><td>recursive_page_table.rs</td><td>递归页表</td><td></td></tr></tbody></table><h2 id="registers"><a href="#registers" class="headerlink" title="registers"></a>registers</h2><table><thead><tr><th>文件名</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>control.rs</td><td>包含寄存器Cr0,Cr2,Cr3,Cr4</td><td>control registers</td></tr><tr><td>debug.rs</td><td>包含寄存器Dr0,Dr1,Dr2,Dr3,Dr6,Dr7</td><td>debug registers</td></tr><tr><td>mod.rs</td><td>mod</td><td></td></tr><tr><td>model_specific.rs</td><td>包含一系列MSR寄存器如Star,LStar,SFMask等</td><td></td></tr><tr><td>mxcsr.rs</td><td>MxCsr寄存器</td><td></td></tr><tr><td>rflags.rs</td><td>RFlags寄存器</td><td></td></tr><tr><td>segmentation.rs</td><td>貌似是一些分段寄存器,包含SS,DS,ES,FS,GS</td><td></td></tr><tr><td>xcontrol.rs</td><td>extended system registers, 包含Xr0</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> x86学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> x86_64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust-C-汇编之间的调用</title>
      <link href="/2022/07/16/Rust-C-%E6%B1%87%E7%BC%96%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8/"/>
      <url>/2022/07/16/Rust-C-%E6%B1%87%E7%BC%96%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 最近在尝试Rust与C之间的混合编译, 在里面还夹杂着汇编文件来写特定的入口函数, 所以写这一篇记录Rust,C与汇编他们之间如何互相调用</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>首先来看C语言的源文件是如何变成可执行文件的</p><ol><li>预处理(hello.c -&gt; hello.i) 将宏#define等替换</li><li>编译(hello.i -&gt; hello.s) 将预处理后的文件编译成汇编代码</li><li>汇编(hello.s -&gt; hello.o) 根据汇编生成目标文件(二进制)</li><li>链接(hello.o -&gt; hello.exe&#x2F;out) 将多个目标文件链接生成可执行代码</li></ol><p>在这个过程中可以看见直接写汇编语言缺少了前面两项, 而C语言还是要生成汇编文件, 因此只要汇编和C语言都遵循一个规则它们就可以互相调用了</p><blockquote><p>在不同的机器上参数传递标准似乎不太一样, 比如x86中似乎是直接将参数入栈以从右向左的方式来传递, 而在x86-64和RISCV等架构用一些专门的寄存器来传参数, 超过多少个参数才会使用栈来传递参数, 对于他们之间的具体差异可以见<a href="https://blog.csdn.net/u010039418/article/details/85275211">Linux X86架构参数传递规则</a>, 本篇文章里面使用x86-64为例, 因为比较常用</p></blockquote><h2 id="C与汇编之间的调用"><a href="#C与汇编之间的调用" class="headerlink" title="C与汇编之间的调用"></a>C与汇编之间的调用</h2><h3 id="C调用汇编"><a href="#C调用汇编" class="headerlink" title="C调用汇编"></a>C调用汇编</h3><p>C(hello.c):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编(test.s):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    .globl add</span><br><span class="line">add:</span><br><span class="line">    pushq%rbp</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">movl%edi, -4(%rbp)</span><br><span class="line">movl%esi, -8(%rbp)</span><br><span class="line">movl-4(%rbp), %edx</span><br><span class="line">movl-8(%rbp), %eax</span><br><span class="line">addl%edx, %eax</span><br><span class="line">popq%rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>执行<code>gcc hello.c test.s</code>编译后即可看到输出了一个3</p><ul><li>在C文件中我们直接用extern拿到了汇编语言的那个函数入口,然后调用并输出结果</li><li>在汇编文件中我们首先保存了<code>%rbp</code>寄存器, 因为在定义中这个是被调用的函数需要保存的寄存器, 随后我们将<code>%rbp</code>设为了栈指针的值, 并把<code>%edi</code>和<code>%esi</code>放入了栈中, 随后将值取出放入到<code>%edx</code>以及<code>%eax</code>中, 最后相加将结果放入<code>%eax</code>, 恢复<code>%rbp</code>的值之后返回</li><li>这个add函数其实是我写了一个C语言函数之后生成汇编文件改写来的hh, 毕竟不是很熟悉x86的指令..</li></ul><h3 id="汇编调用C"><a href="#汇编调用C" class="headerlink" title="汇编调用C"></a>汇编调用C</h3><p>由于C语言调用printf比较方便, 所以我们会采用 C-&gt; 汇编 -&gt; C -&gt; 汇编 -&gt; C的方式打印出我们的结果</p><p>C(hello.c):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,test());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编(test.s):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    .globl add</span><br><span class="line">    .globl test</span><br><span class="line">test:</span><br><span class="line">movl$1, %edi</span><br><span class="line">movl$2, %esi</span><br><span class="line">    call add</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>执行<code>gcc hello.c test.s</code>编译后即可看到输出了一个3</p><ul><li>C文件中拿到了test的入口地址,调用后打印返回值, C语言中提供了add函数来加两个值</li><li>汇编中直接将立即数传入了第一个参数和第二个参数的寄存器中, 然后调用add并返回(因为返回值寄存器没变)</li></ul><h2 id="Rust与汇编之间的调用"><a href="#Rust与汇编之间的调用" class="headerlink" title="Rust与汇编之间的调用"></a>Rust与汇编之间的调用</h2><p>目前我知道的应该是有两种方法调用, 但第一种我试了一下在build的时候好像会报错, 还是先放出来待以后再看看</p><ol><li>利用Rust中的global_asm!宏(注意需要nightly)</li><li>利用build.rs中的cc依赖编译出静态库后在链接时搞在一起</li></ol><p>现在说明第二种的方法</p><p>main.rs:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(a:<span class="type">u32</span>,b:<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test</span>() <span class="punctuation">-&gt;</span> <span class="type">u32</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;<span class="built_in">println!</span>(<span class="string">&quot;Hello, world! &#123;&#125;,&#123;&#125;&quot;</span>,<span class="title function_ invoke__">add</span>(<span class="number">1</span>,<span class="number">2</span>),<span class="title function_ invoke__">test</span>())&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">mul</span>(a:<span class="type">u32</span>,b:<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>&#123;</span><br><span class="line">    a*b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.s:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    .globl test</span><br><span class="line">    .globl mul</span><br><span class="line">    .globl add</span><br><span class="line">add:</span><br><span class="line">    pushq%rbp</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">movl%edi, -4(%rbp)</span><br><span class="line">movl%esi, -8(%rbp)</span><br><span class="line">movl-4(%rbp), %edx</span><br><span class="line">movl-8(%rbp), %eax</span><br><span class="line">addl%edx, %eax</span><br><span class="line">popq%rbp</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">movl$1, %edi</span><br><span class="line">movl$2, %esi</span><br><span class="line">    call mul</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>build.rs:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> cc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    cc::Build::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">file</span>(<span class="string">&quot;src/test.s&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">compile</span>(<span class="string">&quot;my-asm-lib&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cargo.toml</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-dependencies]</span></span><br><span class="line"><span class="attr">cc</span> = <span class="string">&quot;1.0.3&quot;</span></span><br></pre></td></tr></table></figure><p> 具体他们之间怎么调的其实和之前的C语言大同小异, 都是先定义好函数, 之后在链接时把函数入口写入实际的值就好了, 这里就不再赘述了.</p><blockquote><p>在汇编调用Rust函数的时候记得要在函数前面加上#[no_mangle]让Rust编译器不要对这个函数名进行变动, 不然汇编找不到这个函数.</p></blockquote><h2 id="Rust与C之间的调用"><a href="#Rust与C之间的调用" class="headerlink" title="Rust与C之间的调用"></a>Rust与C之间的调用</h2><p> 终于到了我实际要使用的东西了,这里文件较多,首先放上目录:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build.rs</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── c-lib</span><br><span class="line">│   ├── hello.c</span><br><span class="line">│   ├── hello.h</span><br><span class="line">│   ├── test.c</span><br><span class="line">│   └── test.h</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure><p> 接下来一个一个文件来看:</p><p>hello.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hello_world</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_with_value</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!, your value:%d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_test_add</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!, value: %d\n&quot;</span>,add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hello.h:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLO_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLO_H_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hello_world</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_with_value</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_test_add</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>test.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rust_div</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_rust_div</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rust_div(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.h:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEST_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_H_</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_rust_div</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main.rs:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_hello_world</span>();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_with_value</span>(a: <span class="type">u32</span>);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print_test_add</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(a:<span class="type">u32</span>,b:<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test_rust_div</span>(a:<span class="type">u32</span>,b:<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">print_hello_world</span>();</span><br><span class="line">        <span class="title function_ invoke__">print_with_value</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="title function_ invoke__">print_test_add</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;test value:&#123;&#125;&quot;</span>,<span class="title function_ invoke__">add</span>(<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;test div value:&#123;&#125;&quot;</span>,<span class="title function_ invoke__">test_rust_div</span>(<span class="number">10</span>,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">rust_div</span>(a:<span class="type">u32</span>,b:<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>&#123;</span><br><span class="line">    a/b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>build.rs:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> cc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    cc::Build::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">files</span>(<span class="built_in">vec!</span>[<span class="string">&quot;c-lib/hello.c&quot;</span>,<span class="string">&quot;c-lib/test.c&quot;</span>])</span><br><span class="line">        .<span class="title function_ invoke__">compile</span>(<span class="string">&quot;my-asm-lib&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cargo.toml:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;learn&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-dependencies]</span></span><br><span class="line"><span class="attr">cc</span> = <span class="string">&quot;1.0.3&quot;</span></span><br></pre></td></tr></table></figure><p>执行cargo r输出应该是:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140142633.png" alt="image-20220716200041179"></p><p>由于是rust主导生成的执行文件,因此main函数在rust中, 将Rust编译为库文件然后将C编译后的文件与Rust文件链接应该也可以将main函数用C语言写, main.rs中我们调用了C语言的5个函数,这5个函数的功能分别为:</p><ul><li>测试Rust调用C语言的函数</li><li>测试Rust调用C语言的函数并传参</li><li>测试Rust调用C语言的函数,并且那个函数调用了C语言的函数</li><li>测试Rust调用C语言在另外一个文件的函数并传参,打印返回值</li><li>测试Rust调用C语言在另外一个文件的函数并传参,打印返回值, 调用的函数调用了Rust的函数<code>rust_div</code></li></ul><h2 id="Rust-C-汇编联合"><a href="#Rust-C-汇编联合" class="headerlink" title="Rust, C, 汇编联合"></a>Rust, C, 汇编联合</h2><p>理清楚了这些, 最后来看看三者合并怎么调用, 其实方法很简单, Rust自带的cc功能蛮强大了, 可以编译c文件为库(可以加上汇编文件)然后自动合并Rust与C, 代码简单易懂. 或者需要在Rust当中添加汇编代码就用global_asm或者内联汇编</p><p>我写这篇文章的目的主要是为了 让汇编文件在Rust中使用到C语言的#define宏(要直接复制到Rust中感觉有点麻烦..而且汇编中也有#ifndef语句,Rust编译的话不认), 现在看来只能将汇编文件与c语言一起编译然后与Rust链接在一起了..因为编译生成库后已经经过预处理部分了</p><p>不过之前尝试将cc编译后的库中的某个函数放到可执行文件中的section失败了, 上网查说是删section简单,但添加section比较困难, 因此会报错, 可以看下面这张图:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140142261.png" alt="image-20220716202655731"></p><p>貌似只能将函数重定向而不能添加代码..还不了解如何对rust-lld加<code>-mno-relax</code>, 这方面还得再学习</p>]]></content>
      
      
      <categories>
          
          <category> Rust学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> C </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISCV-CSR寄存器详解</title>
      <link href="/2022/07/14/RISCV-CSR%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/07/14/RISCV-CSR%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>随着接触越来越多的寄存器, 这篇文章在未来会更新, S-mode的一些寄存器功能与M-mode中差不多名字的寄存器功能类似, 因此只截了图, 网站好像不支持markdown的目录结构,因此要找对应的寄存器说明可以直接网页Ctrl+F查找名字就好了</strong></p><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><ul><li><strong>WARL</strong>: (Write any value, read legal value) (写任何值,读合法值)</li><li><strong>WLRL</strong>: (Write&#x2F;read only legal value) (读写合法值)</li><li><strong>WPRL</strong>: (Reserved writes preseve values, reads ignore value) (将来可能会用到)</li></ul><h2 id="CSR寄存器快速一览-M-mode与S-mode"><a href="#CSR寄存器快速一览-M-mode与S-mode" class="headerlink" title="CSR寄存器快速一览(M-mode与S-mode)"></a>CSR寄存器快速一览(M-mode与S-mode)</h2><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140136063.png" alt="image-20220714195516470"></p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140136611.png" alt="image-20220714195524849"></p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140136960.png" alt="image-20220714195614309"></p><h2 id="M-mode-CSR寄存器"><a href="#M-mode-CSR寄存器" class="headerlink" title="M-mode CSR寄存器"></a>M-mode CSR寄存器</h2><h3 id="Machine-ISA-Register-misa"><a href="#Machine-ISA-Register-misa" class="headerlink" title="Machine ISA Register (misa)"></a>Machine ISA Register (misa)</h3><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140137619.png" alt="image-20220713105831339"></p><ul><li><p>MXL(Machine XLEN): 代表了XLEN的大小, 对应关系为:</p><table><thead><tr><th>MXL</th><th>XLEN</th></tr></thead><tbody><tr><td>1</td><td>32</td></tr><tr><td>2</td><td>64</td></tr><tr><td>3</td><td>128</td></tr></tbody></table></li><li><p>剩下的Extensions每个bit代表的意思为(感觉有点深了,就放个图吧):<img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140137552.png" alt="image-20220713110425142"></p></li></ul><h3 id="Machine-Status-Registers-mstatus-and-mstatush"><a href="#Machine-Status-Registers-mstatus-and-mstatush" class="headerlink" title="Machine Status Registers (mstatus and mstatush)"></a>Machine Status Registers (mstatus and mstatush)</h3><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140137173.png" alt="image-20220713110526606"></p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140137449.png" alt="image-20220713110549666"></p><ul><li>对于RV32,除开mstatus寄存器还有mstatush寄存器作为拓展</li><li>RV32相比RV64,少了两个字段: SXL[1:0] 以及 UXL[1:0]</li></ul><p><strong>各个字段含义(~代表与上方相同,注意要替换对应的特权模式,-代表暂无):</strong></p><table><thead><tr><th>字段名称</th><th>bit</th><th>全称(*代表不确定)</th><th>功能</th><th>特权模式</th><th>补充</th></tr></thead><tbody><tr><td>SIE</td><td>1</td><td>Supervisor Interrupt Enable</td><td>全局中断启动位</td><td>S</td><td>-</td></tr><tr><td>MIE</td><td>3</td><td>Machine Interrupt Enable</td><td>~</td><td>M</td><td>-</td></tr><tr><td>SPIE</td><td>5</td><td>Supervisor Previous Interrupt Enable*</td><td>在trap之前的中断状态</td><td>S</td><td>进入中断前的SIE值,用于使用sret时再次赋给SIE</td></tr><tr><td>MPIE</td><td>7</td><td>Machine Previous Interrupt Enable *</td><td>~</td><td>M</td><td>进入中断前的MIE值,用于使用sret时再次赋给MIE</td></tr><tr><td>SPP</td><td>8</td><td>Supervisor Previous Privilege</td><td>进入trap之前的特权模式</td><td>S</td><td>0-&gt;U-mode, 1-&gt; Other mode</td></tr><tr><td>MPP</td><td>[12:11]</td><td>Machine Previous Privilege</td><td>~</td><td>M</td><td>设置为对应的特权值</td></tr><tr><td>SXL</td><td>[35:34]</td><td>Supervisor XLEN</td><td>控制XLEN的值,具体可以参考之前的MXL</td><td>S</td><td>RV64中值为0的时候代表不支持S-mode</td></tr><tr><td>UXL</td><td>[33:32]</td><td>User XLEN</td><td>~</td><td>U</td><td>~</td></tr><tr><td>MPRV</td><td>17</td><td>Modify PRiVilege</td><td>loads和stores指令执行时的特权模式</td><td>-</td><td>0 -&gt; loads和stores正常执行<br />1 -&gt; loads和stores是翻译且被保护的,当前的特权模式被设置到MPP中<br />如果不支持U-mode则为只读0, 执行mret或sret将特权模式设为了低于M的则会设MPRV&#x3D;0</td></tr><tr><td>MXR</td><td>19</td><td>Make eXecutable Readable</td><td>loads虚拟内存时的特权模式</td><td>-</td><td>0 -&gt; 只能loads标记为可读的页面(R&#x3D;1)<br />1 -&gt; 可以loads标记为刻度或可执行的页面(R&#x3D;1&#x2F;X&#x3D;1)<br />如果虚拟内存无效则MXR无作用, 如果不支持S-mode,则MXR设为只读0</td></tr><tr><td>SUM</td><td>18</td><td>permit Supervisor User Memory access</td><td>用于保护U-mode内存不被S-mode访问(看补充说明吧)</td><td>-</td><td>0 -&gt; S-mode下访问U-mode可以访问的内存页会出错(还是说生成一个page fault?不太确定)<br />1-&gt; S-mode可以访问U-mode内存页<br />如果虚拟内存无效或者不执行在S-mode, SUM没用, 当MPRV&#x3D;1, MPP&#x3D;S时SUM有用</td></tr><tr><td>MBE</td><td>37&#x2F;5</td><td>Machine Big Endian*</td><td>记录M-mode是否为大小端, 0 -&gt; 小端, 1 -&gt; 大端</td><td>M</td><td>描述对应的模式下加载存储内存是大端还是小端(取指令总是小端)</td></tr><tr><td>SBE</td><td>36&#x2F;4</td><td>Supervisor Big Endian*</td><td>~</td><td>S</td><td>~</td></tr><tr><td>UBE</td><td>6</td><td>User Big Endian*</td><td>~</td><td>U</td><td>~</td></tr><tr><td>TVM</td><td>20</td><td>Trap Virtual Memory</td><td>拦截S-mode 虚拟内存管理操作</td><td>-</td><td>1 -&gt; 读取写入 satp CSR 或者执行 SFENCE.VMA 或者 SINVAL.VMA 指令并且在S-mode会引发非法指令异常<br />0 -&gt; 允许执行</td></tr><tr><td>TW</td><td>21</td><td>Timeout Wait</td><td>拦截 WFI 指令</td><td>-</td><td>0 -&gt; WFI 指令允许在低特权模式中执行(可能因为其他原因阻止执行)<br />1 -&gt; WFI 指令如果在低特权模式中执行并且没有在特定时间内执行完成, 就会引发一个非法指令异常</td></tr><tr><td>TSR</td><td>22</td><td>Trap SRET</td><td>拦截 SRET 指令</td><td>-</td><td>1 -&gt; 尝试在S-mode中执行 SRET指令会引发非法指令异常<br />0 -&gt; 允许使用SRET</td></tr><tr><td>FS</td><td>[14:13]</td><td>Floating Status*</td><td>浮点单元的状态</td><td>-</td><td>包括寄存器 f0-f31,以及fcsr, frm, fflags CSRs</td></tr><tr><td>VS</td><td>[10:9]</td><td>Vector Status*</td><td>向量扩展状态</td><td>-</td><td>包括寄存器 v0-v31, 以及 vcsr, vxrm, vxsat, vstart, vl, vtype, vlenb CSRs</td></tr><tr><td>XS</td><td>[16:15]</td><td>-</td><td>额外U-mode以及对应的状态(?)</td><td>-</td><td>-</td></tr><tr><td>SD</td><td>63&#x2F;31</td><td>-</td><td>只读位, 表示FS, XS, VS的总体状态</td><td>-</td><td>运算方式: SD&#x3D;((FS&#x3D;&#x3D;11) OR (XS&#x3D;&#x3D;11) OR (VS&#x3D;&#x3D;11))</td></tr></tbody></table><p><strong>补充:</strong></p><ul><li><strong>大小端</strong>:<img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140137266.png" alt="大小端"></li><li>FS, VS, XS 代表的意思:<img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140138131.png" alt="image-20220714193518123"><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140138432.png" alt="image-20220714193739337"></li><li>SV39:<img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140138623.png" alt="image-20220714195005458"></li><li>所有拦截目标特权模式的位,如果不支持目标特权模式,则始终为只读0</li></ul><h3 id="Machine-Trap-Vector-Base-Address-Register-mtvec"><a href="#Machine-Trap-Vector-Base-Address-Register-mtvec" class="headerlink" title="Machine Trap-Vector Base-Address Register (mtvec)"></a>Machine Trap-Vector Base-Address Register (mtvec)</h3><p>用于保存处理trap的入口函数地址</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140138529.png" alt="image-20220714195320839"></p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140138510.png" alt="image-20220714195327654"></p><h3 id="Machine-Trap-Delegation-Registers-medeleg-and-mideleg"><a href="#Machine-Trap-Delegation-Registers-medeleg-and-mideleg" class="headerlink" title="Machine Trap Delegation Registers (medeleg and mideleg)"></a>Machine Trap Delegation Registers (medeleg and mideleg)</h3><ul><li>medeleg全称: Machine Exception DELEGate</li><li>mideleg全称: Machine Interrupt DELEGate</li></ul><p>通过全称可以看到,一个是用于异常的代理,一个是用于中断的代理,在手册中它们的具体值分别是</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140138015.png" alt="image-20220715213727761"></p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140138655.png" alt="image-20220715213736630"></p><p>具体使用规则很简单, 设置一些特定的中断&#x2F;异常对应的位, 之后如果在S-mode或者U-mode发生的中断&#x2F;异常会进入到S-mode的trap handler, 如果trap代理到了S-mode, 会有以下寄存器操作:</p><ul><li>scause会写入发生trap的类型</li><li>sepc会写入发生trap的那个指令虚拟地址</li><li>stval会写入特定的数据</li><li>mstatus中的SPP位会写入trap前的特权模式</li><li>mstatus中的SPIE会写入trap前的SIE位的值,用于返回时恢复</li><li>mstatus中的SIE会置0</li><li>mcause,mepc,mtval以及mstatus中的MPP,MPIE不会写入东西</li></ul><p>具体哪一位对应哪一个中断&#x2F;异常,可见下面mcause中的表格, Interrupt对应mideleg, Exception对应medeleg, code对应哪一位,比如在 Interrupt中的Supervisor software interrupt, 在 mideleg对应的是从右向左第二位(从0开始)</p><h3 id="Machine-Interrupt-Registers-mip-and-mie"><a href="#Machine-Interrupt-Registers-mip-and-mie" class="headerlink" title="Machine Interrupt Registers (mip and mie)"></a>Machine Interrupt Registers (mip and mie)</h3><p>mie,mip分别是MXLEN长度的寄存器:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140138967.png" alt="image-20220715221103066"></p><p>先来说说一个中断想要进入M-mode需要满足什么条件:</p><ol><li>当前特权模式为M并且mstatus寄存器的MIE位被设置, 或者当前特权模式等级低于M-mode</li><li>mip和mie对应的bit同时被设置</li><li>如果mideleg存在,则对应的bit不能被设置</li></ol><p>mip与mie每一位对应的中断类型:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140139401.png" alt="image-20220715221113706"></p><p> 寄存器mip中的每位可以是可写的，也可以是只读的。当mip中的第i位可写时，一个挂起的中断i可以将bit i置0。如果interrupt i可以变成挂起态，但是mip中的bit i是只读的，那么实现必须提供一些其他机制来清除挂起的中断。</p><p> 各个比特位所代表的意思:</p><table><thead><tr><th>bit名</th><th>说明</th><th>补充</th></tr></thead><tbody><tr><td>mip.MEIP及mie.MEIE</td><td>机器级外部中断挂起和机器级外部中断启用</td><td>MEIP为只读, 只能通过特定的平台终端管理器设置或清除</td></tr><tr><td>mie.MTIP及mie.MTIE</td><td>机器级时钟中断挂起和机器级时钟中断启用</td><td>MTIP为只读,只能通过写入内存映射的M-mode 时钟比较寄存器(timer compare register)来清除</td></tr><tr><td>mie.MSIP及mie.MSIE</td><td>机器级软件中断挂起和机器级软件中断启用</td><td>MSIP为只读,只能通过访问内存映射的控制寄存器来写入, 控制寄存器被远程harts用来提供机器级处理器间的中断, 一个hart可以相同的内存映射控制寄存器来写入他自己的MSIP bit.如果一个系统只有一个hart或者一个平台标准支持通过外部中断(MEI)来传递机器级处理期间的中断, 则 MSIP和MSIE可能都设为只读0</td></tr><tr><td>mip.SEIP及mie.SEIE</td><td>Supervisor-level 外部中断挂起和Supervisor-level 外部中断启用</td><td>SEIP是可写的, 可能会被M-mode软件去通知S-mode有一个外部中断正在挂起, 平台中断控制器可能也会生成Supervisor level 外部中断</td></tr><tr><td>Supervisor level外部中断是否挂起是基于这个表达式: (软件可写的SEIP bit)</td><td>(外部中断控制器信号).</td><td></td></tr><tr><td>当使用CSR指令读取mip时, SEIP bit 返回的值为:(软件可写的bit)</td><td>(外部中断控制器信号), 但是外部中断信号并不用于计算写入到SEIP寄存器的值(也就是说外部中断信号与SEIP寄存器中的值没有关联, 但读取的时候会加上这个信号, 读取的不一定是实际在寄存器中的)</td><td></td></tr><tr><td>能通过用 CSRRS 或者 CSRRC来读取更改或者写入实际SEIP的值</td><td></td><td></td></tr><tr><td>mip.STIP及mie.STIE</td><td>Supervisor-level 时钟中断挂起和Supervisor-level 时钟中断启用</td><td>STIP是可写的，可通过M-mode的软件传递timer中断到S-mode</td></tr><tr><td>mip.SSIP及mie.SSIE</td><td>Supervisor-level 软件中断挂起和Supervisor-level 软件中断启用</td><td>SSIP是可写的，可以通过特定的平台中断控制器设置为1</td></tr></tbody></table><h3 id="Hardware-Performance-Monitor-HPM"><a href="#Hardware-Performance-Monitor-HPM" class="headerlink" title="Hardware Performance Monitor (HPM)"></a>Hardware Performance Monitor (HPM)</h3><p> M-mode包含一系列基础的硬件性能监控设备, mcycle CSR寄存器记录着一个hart运行时他所在的处理器核执行的clock cycles. minstret CSR寄存器记录一个hart已经执行的指令数量. 这两个寄存器无论是在RV32还是RV64都是64位的.</p><p> 计数寄存器在hart重置后是一个随机值, 可以被写入一个特定的值, CSR写入在写入指令结束后生效(意思应该是当前指令不计算在重置后的值). mcycle CSR可能会被多个hart共享, 因为有一些核会有超线程技术, 比如一核二线程, 这种时候平台需要提供一个机制去定义哪些harts共享一个mcycle CSR.</p><p> 硬件性能监控器包含29个额外的64位事件计数器, mhpmcounter3-mhpmcounter31. 还存在一系列用于选择事件的 CSR寄存器, mhpmevent3-mhpmevent31, 他们都是MXLEN bit大小的WARL寄存器, 用于控制拿一些事件会导致计数器增长, 这些事件的内容由平台定义, 但是event 0 定义为 “没有事件”. 所有的计数器都要被实现, 但存在一种合法的实现, 就是将counter和对应的event select 设置为只读0</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140139751.png" alt="image-20220715234229952"></p><p> 如果MXLEN&#x3D;32, 直接读寄存器会读取到0-31位的数据, 在对应的寄存器后面加个h即可读取32-63位的数据.</p><blockquote><p><strong>内存映射寄存器 - Machine Time Registers (mtime 及 mtimecmp)</strong></p><p>该寄存器记录的是现实生活中时间, 暴露为内存映射 M-mode 读写寄存器 mtime, mtime需要以固定的频率递进, 平台需要提供一个方法去定义一个mtime tick的周期, 如果mtime寄存器溢出,则会重置为0(原话:The mtime register will wrap around if the count overflows.)</p><p>mtime在RV32和RV64中都以64位的精度存在, 平台提供了一个64位大小的内存映射M-mode 时间对比寄存器(mtimecmp). 如果mtime的值大于mtimecmp, 则一个machine timer interrupt会挂起(寄存器的值被设定为无符号整型). 中断会一直存在知道mtimecmp大于mtime. 这个中断是否发生同时也要看mie CSR寄存器中的MTIE bit是否设置为1.</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140139154.png" alt="image-20220716000544831"></p></blockquote><h3 id="Machine-Counter-Enable-Register-mcounteren"><a href="#Machine-Counter-Enable-Register-mcounteren" class="headerlink" title="Machine Counter-Enable Register (mcounteren)"></a>Machine Counter-Enable Register (mcounteren)</h3><p> 这个寄存器主要是保护上面说的HPM不被S-mode以及U-mode访问, 寄存器的结构如下:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140139795.png" alt="image-20220715234554087"></p><p> 如果HPM对应的bit为1, 则代表mcycle, minstret…可以被S-mode, U-mode访问, 如果为0则代表不能被访问, 如果S-mode, U-mode访问了, 则会将引发非法指令异常</p><h3 id="Machine-Counter-Inhibit-CSR-mcountinhibit"><a href="#Machine-Counter-Inhibit-CSR-mcountinhibit" class="headerlink" title="Machine Counter-Inhibit CSR (mcountinhibit)"></a>Machine Counter-Inhibit CSR (mcountinhibit)</h3><p> 这个寄存器控制HPM的增长, 结构和mcounteren类似(注意TM位没有了):</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140139692.png" alt="image-20220715234913533"></p><ul><li>如果对应的位为0, 则代表对应的计数器可以增长, 如果为1则代表对应的计数器不会增长, 这个寄存器不会影响HPM的可访问性.</li><li>mcycle CSR可以在多个hart间共享. 同理, CY字段也应该在这些hart之间共享.</li><li>如果未实现该寄存器, 则功能与全为0相同</li><li>如果不需要cycle和instret计数器时, 最好可以将他们关掉以减少能量消耗</li><li>由于时间计数器在多核是共享的, 因此它不能被此寄存器影响.</li></ul><h3 id="Machine-Scratch-Register-mscratch"><a href="#Machine-Scratch-Register-mscratch" class="headerlink" title="Machine Scratch Register (mscratch)"></a>Machine Scratch Register (mscratch)</h3><p>用于保存M-mode的hart本地上下文空间的指针, 在进入M-mode trap handler时与user寄存器交换</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140139803.png" alt="image-20220714195753070"></p><h3 id="Machine-Exception-Program-Counter-mepc"><a href="#Machine-Exception-Program-Counter-mepc" class="headerlink" title="Machine Exception Program Counter (mepc)"></a>Machine Exception Program Counter (mepc)</h3><p>当进入M-mode trap handler时用于记录进入之前运行指令的虚拟地址</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140139562.png" alt="image-20220714200053723"></p><h3 id="Machine-Cause-Register-mcause"><a href="#Machine-Cause-Register-mcause" class="headerlink" title="Machine Cause Register (mcause)"></a>Machine Cause Register (mcause)</h3><p>进入trap之前记录是因为什么引发的trap,如果是中断则会将最顶的那一位设为1</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140139110.png" alt="image-20220714200245298"></p><p>对应表格:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140140393.png" alt="image-20220714200620015"></p><p>如果指令触发多个异常,则优先级如下:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140140242.png" alt="image-20220714200701182"></p><h3 id="Machine-Trap-Value-Register-mtval"><a href="#Machine-Trap-Value-Register-mtval" class="headerlink" title="Machine Trap Value Register (mtval)"></a>Machine Trap Value Register (mtval)</h3><p>进入M-mode trap之前, mtval要么设为0, 要么写入一些辅助处理trap的异常信息.</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140140518.png" alt="image-20220714200741884"></p><p>如果在断点(breakpoint), 地址错位(address-misaligned), 访问错误(access-fault) 或者 执行获取(fetch), 加载(load), 存储(store) 指令触发的page-fault 时 mtval写入了一个非0值,则代表发生错误的虚拟地址</p><p>剩下的什么错误mtval写入对应值具体看<a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">RISCV特权英文手册</a>的3.1.16.</p><h2 id="S-mode-CSR寄存器"><a href="#S-mode-CSR寄存器" class="headerlink" title="S-mode CSR寄存器"></a>S-mode CSR寄存器</h2><h3 id="Supervisor-Status-Register-sstatus"><a href="#Supervisor-Status-Register-sstatus" class="headerlink" title="Supervisor Status Register (sstatus)"></a>Supervisor Status Register (sstatus)</h3><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140140866.png" alt="image-20220714201648045"></p><p>没怎么细看,但乍一看感觉这里面的每个bit mstatus都有..就先不记录了吧</p><h3 id="Supervisor-Trap-Vector-Base-Address-Register-stvec"><a href="#Supervisor-Trap-Vector-Base-Address-Register-stvec" class="headerlink" title="Supervisor Trap Vector Base Address Register (stvec)"></a>Supervisor Trap Vector Base Address Register (stvec)</h3><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140141271.png" alt="image-20220714201941271"></p><h3 id="Supervisor-Interrupt-Registers-sip-and-sie"><a href="#Supervisor-Interrupt-Registers-sip-and-sie" class="headerlink" title="Supervisor Interrupt Registers (sip and sie)"></a>Supervisor Interrupt Registers (sip and sie)</h3><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140141254.png" alt="image-20220716000826835"></p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140141694.png" alt="image-20220716001105713"></p><h3 id="Counter-Enable-Register-scounteren"><a href="#Counter-Enable-Register-scounteren" class="headerlink" title="Counter-Enable Register (scounteren)"></a>Counter-Enable Register (scounteren)</h3><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140141826.png" alt="image-20220716000922781"></p><p> 与mcounteren类似,这个寄存器控制U-mode对HPM的访问控制, 如果为0, 则U-mode访问会触发非法指令异常,如果为1则不会.</p><h3 id="Supervisor-Scratch-Register-sscratch"><a href="#Supervisor-Scratch-Register-sscratch" class="headerlink" title="Supervisor Scratch Register (sscratch)"></a>Supervisor Scratch Register (sscratch)</h3><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140141745.png" alt="image-20220714202013751"></p><h3 id="Supervisor-Exception-Program-Counter-sepc"><a href="#Supervisor-Exception-Program-Counter-sepc" class="headerlink" title="Supervisor Exception Program Counter (sepc)"></a>Supervisor Exception Program Counter (sepc)</h3><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140141142.png" alt="image-20220714202142616"></p><h3 id="Supervisor-Cause-Register-scause"><a href="#Supervisor-Cause-Register-scause" class="headerlink" title="Supervisor Cause Register (scause)"></a>Supervisor Cause Register (scause)</h3><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140141100.png" alt="image-20220714202131444"></p><h3 id="Supervisor-Trap-Value-stval-Register"><a href="#Supervisor-Trap-Value-stval-Register" class="headerlink" title="Supervisor Trap Value (stval) Register"></a>Supervisor Trap Value (stval) Register</h3><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140141667.png" alt="image-20220714202124852"></p><h3 id="Supervisor-Address-Translation-and-Protection-satp-Register"><a href="#Supervisor-Address-Translation-and-Protection-satp-Register" class="headerlink" title="Supervisor Address Translation and Protection (satp) Register"></a>Supervisor Address Translation and Protection (satp) Register</h3><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140141119.png" alt="image-20220714202313742"></p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140141388.png" alt="image-20220714202319803"></p><p>用于控制S-mode 地址翻译和保护, satp 中保存了根页表的PPN, ASID全称为 Address Space IDentifier, 目前知道的是可以用来唯一标识进程, 提供进程地址空间保护, MODE为地址转换的模式:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140141170.png" alt="image-20220714203101682"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">RISCV特权英文手册</a></li><li><a href="https://blog.csdn.net/Pandacooker/article/details/116423306">RISCV特权寄存器及指令</a></li><li><a href="https://blog.csdn.net/lee_ham/article/details/103107135">TLB, PCID与ASID</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> RISCV学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISCV </tag>
            
            <tag> 寄存器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISCV特权模式,中断与CSR寄存器</title>
      <link href="/2022/07/11/RISCV%E7%89%B9%E6%9D%83%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E6%96%AD%E4%B8%8ECSR%E5%AF%84%E5%AD%98%E5%99%A8/"/>
      <url>/2022/07/11/RISCV%E7%89%B9%E6%9D%83%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E6%96%AD%E4%B8%8ECSR%E5%AF%84%E5%AD%98%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="特权模式"><a href="#特权模式" class="headerlink" title="特权模式"></a>特权模式</h2><p>四种特权模式:</p><table><thead><tr><th>名</th><th>缩写</th><th>序号</th></tr></thead><tbody><tr><td>Machine mode</td><td>M-mode</td><td>3</td></tr><tr><td>Hypervisor mode</td><td>H-mode</td><td>2</td></tr><tr><td>Supervisor mode</td><td>S-mode</td><td>1</td></tr><tr><td>User mode</td><td>U-mode</td><td>0</td></tr></tbody></table><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>主要类型:</p><ul><li>软件中断, 通过写入 mip CSR寄存器触发的中断</li><li>时钟中断, 由寄存器mtime和mtimecmp控制</li><li>外部中断, 受RISC-V 平台级中断控制器(Platform Level Interrupt Controller, PLIC)控制的,由外部设备触发的中断</li></ul><h4 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h4><p> 需要通过CSR手动开启, 否则CPU不会接受到任何中断(除了不可屏蔽中断), CPU异常在异常条件满足就会触发,无法通过CSR屏蔽</p><p>开启中断步骤:</p><ul><li>mstatus[MIE]总开关(置1)</li><li>mie CSR寄存器为针对每种中断类型的独立开关</li></ul><blockquote><p>mstatus 前面的m代表的是M-mode的status寄存器, 如果是S-mode, 则寄存器名为 sstatus, 在看这些寄存器名时如果读不通可以看最前面的可不可以翻译为特权级</p></blockquote><p>中断响应程序的地址需要放在 mtvec CSR中,目前 RISCV 支持两种类型的中断向量:</p><ul><li>直接模式(direct), 所有中断均发送给同一个中断响应程序</li><li>向量化模式(vectored), 外部中断根据中断类型发送给不同的中断响应程序, 所有的异常依旧发送给同一个异常响应程序</li></ul><p>中断发生时, CPU的一些操作:</p><ul><li>将 <strong>发生异常的指令</strong> 或者 <strong>被中断时的下一条指令</strong> 的PC地址放入 mepc CSR</li><li>将中断类型码放入 mcause CSR</li><li>如果中断带有附加的信息, 则会放入 mtval CSR</li><li>如果是外部引发的中断, 则会将 mstatus[MPIE] &#x3D; mstatus[MIE], 并且 mstatus[MIE] &#x3D; 0, 相当于进入中断响应程序前暂时关闭中断, PIE为 previous interrupt enabled的缩写</li><li>将当前特权模式序号(machine mode那些)放入mstatus[MPP]中, 并将当前模式设为M-mode</li><li>根据 mtvec CSR的值决定中断响应程序的地址, 并跳转</li></ul><p>默认处理的特权级为M-mode, 但也可以配置中断代理,下放到低权限的模式(待补充)</p><p>M-mode的中断响应程序通过 mret 指令 从中断中返回, 该指令执行:</p><ul><li>将当前特权模式设置回 mstatus[MPP]</li><li>令 <code>mstatus[MIE] = mstatus[MPIE]</code>，以还原发生中断前的中断开关；</li><li><code>mstatus[MPIE] = 1</code>；</li><li><code>mstatus[MPP]</code> 将被设为 U（如果 CPU 不支持 U-mode，则设为 M）；</li><li>将 PC 的值设为 <code>mepc</code> 的值，以返回中断前的程序。</li></ul><h2 id="CSR"><a href="#CSR" class="headerlink" title="CSR"></a>CSR</h2><h3 id="CSR指令"><a href="#CSR指令" class="headerlink" title="CSR指令"></a>CSR指令</h3><p>CSR 的全称为 <strong>控制与状态寄存器</strong>, 反映和控制 CPU 当前的状态和执行机制。(通用寄存器不一样)</p><table><thead><tr><th>指令</th><th>说明</th><th>样例</th><th>样例说明</th></tr></thead><tbody><tr><td>csrr</td><td>读取CSR值到通用寄存器中</td><td>csrr t0, mstatus</td><td>将mstatus值读入t0</td></tr><tr><td>csrw</td><td>将通用寄存器值写入CSR中</td><td>csrw mstatus, t0</td><td>将t0的值写入mstatus</td></tr><tr><td>csrs</td><td>将CSR中的指定bit设为1</td><td>csrsi mstatus, (1&lt;&lt;2)</td><td>将mstatus的右侧第3位置1(i代表immediate value)</td></tr><tr><td>csrc</td><td>将CSR中的指定bit设为0</td><td>csrci mstatus, (1&lt;&lt;2)</td><td>将mstatus的右侧第3位置0(i代表immediate value)</td></tr><tr><td>csrrw</td><td>读取CSR值到通用寄存器内,然后将另一个值写入CSR</td><td>csrrw t0, mstatus, t1</td><td>值交换为: t1 写入 mstatus 写入 t0</td></tr><tr><td>csrrs</td><td>读取一个 CSR 的值到通用寄存器，然后把该 CSR 中指定的 bit 置 1</td><td>暂无</td><td></td></tr><tr><td>csrrc</td><td>读取一个 CSR 的值到通用寄存器，然后把该 CSR 中指定的 bit 置 0</td><td>暂无</td><td></td></tr></tbody></table><h3 id="CSR-寄存器"><a href="#CSR-寄存器" class="headerlink" title="CSR 寄存器"></a>CSR 寄存器</h3><p>这里放从 <code>RISC-V 特权指令集手册</code> 的截图:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140135389.png" alt="image-20220711224339458"></p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140135983.png" alt="image-20220711224350240"></p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140135090.png" alt="image-20220711224355903"></p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140136840.png" alt="image-20220711224454587"></p><p><strong>比较重要的寄存器可能会单独拉出来一章讲</strong></p><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140136637.jpeg" alt="img"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h2><ul><li><a href="https://www.icfedu.cn/wp-content/uploads/2021/03/riscv-privileged-spec-v1.7%E4%B8%AD%E6%96%87%E7%89%88.pdf">RISC-V 特权指令集手册</a></li><li><a href="https://juejin.cn/post/6891962672892837901">中断及CSR寄存器</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> RISCV学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISCV </tag>
            
            <tag> 寄存器 </tag>
            
            <tag> 特权模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust堆, 智能指针</title>
      <link href="/2022/05/05/Rust-%E5%A0%86-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2022/05/05/Rust-%E5%A0%86-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>写着一篇的目的主要是看到虚拟内存的struct等过多，看了下面忘了上面的，所以记录一下，之前章节的可能会补充</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h3><p> 在编译期由编译器完成，已经知道了当前变量所占大小，分配一块固定的内存存储起来</p><h3 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h3><p> 应用有一块可以动态增减的内存空间-堆，需要对这一块堆进行管理，如果堆的大小固定，则为连续内存分配问题。有一个概念，内存碎片，指的是无法分配和使用的内存空间，进一步细分有：</p><ul><li>内碎片：已经被分配出去，但是占有的应用不使用这块区域，操作系统无法利用这块区域</li><li>外碎片：没被分配出去，但是太小了以至于无法分配给其他应用</li></ul><p> 经典的C语言中有动态分配的函数，malloc以及free，这两个函数用于动态分配或者释放内存。相比较静态分配，由于动态分配有一个连续内存分配算法，所以会有一些额外的开销。</p><h3 id="Rust中的堆"><a href="#Rust中的堆" class="headerlink" title="Rust中的堆"></a>Rust中的堆</h3><ul><li>裸指针 <code>*const T/*mut T</code> 与C中的普通指针基本相等</li><li>引用<code>&amp;T/&amp;mut T</code> 实际上是一个地址范围（还不清楚为啥）</li></ul><p><strong>Rust中与动态内存分配相关的智能指针：</strong></p><ul><li><code>Box&lt;T&gt;</code>在创建时会在堆上分配一个类型为T的变量，当<code>Box&lt;T&gt;</code>回收时，指向的变量也会被回收</li><li><code>Rc&lt;T&gt;</code>为单线程上使用的引用奇数类型, 同时可以有多个智能指针指向同一个堆上变量<code>Rc&lt;T&gt;</code>, 堆上另外一个位置存储了这个变量目前引用的次数N, 如果N的数量变为0, 则会被回收</li><li><code>RefCell&lt;T&gt;</code> , 与Box等智能指针不同的是, 如果违反借用规则, 会在运行时panic退出, 它可以在自身不可变的情况下修改内部的值</li><li><code>Mutex&lt;T&gt;</code> 为互斥锁,在多线程中使用, 能避免数据竞争, 它时常与<code>Arc&lt;T&gt;</code>一起使用</li></ul><p>还有一些其他的:</p><ul><li>向量<code>Vec&lt;T&gt;</code></li><li>键值对容器<code>BTreeMap&lt;K,V&gt;</code></li><li>有序集合<code>BTreeSet&lt;T&gt;</code></li><li>链表<code>LinkedList&lt;T&gt;</code></li><li>双端队列<code>VecDeque&lt;T&gt;</code></li><li>变长字符串<code>String</code></li></ul><p>图示:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140134723.png" alt="image-20220505105723816"></p>]]></content>
      
      
      <categories>
          
          <category> Rust学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的世界1.18mod开发学习(1)-环境搭建</title>
      <link href="/2022/03/10/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(9)-Block%20Entities/"/>
      <url>/2022/03/10/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(9)-Block%20Entities/</url>
      
        <content type="html"><![CDATA[<h2 id="Block-Entities"><a href="#Block-Entities" class="headerlink" title="Block Entities"></a>Block Entities</h2><p> 在forge文档1.16版本时，Block Entities还叫作Tile Entities，在1.17.x文档后被称为了Block Entities，在这里我会称呼Block Entities</p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p> 与Block State不同，Block State的各种状态是初始化的时候已经定死，但游戏中的方块可能需要存储其他的一些数据，Block Entities可以作为一种解决方案用于存储动态数据，例子比如箱子，熔炉等</p><h3 id="注册自己的Block-Entities"><a href="#注册自己的Block-Entities" class="headerlink" title="注册自己的Block Entities"></a>注册自己的Block Entities</h3><p>待填坑…</p>]]></content>
      
      
      <categories>
          
          <category> 我的世界mod开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的世界mod开发 </tag>
            
            <tag> forge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的世界1.18mod开发学习(8)-合成</title>
      <link href="/2022/03/05/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(8)-%E5%90%88%E6%88%90/"/>
      <url>/2022/03/05/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(8)-%E5%90%88%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h2><p> 目前我们的物品没有办法进行合成，在生存模式下无法合成，只能靠创造拿，所以需要在游戏内加入合成配方，默认情况下，forge会读取.&#x2F;data&#x2F;{modid}&#x2F;recipes下的所有配方，一般放在resources下，配方的文件类型为json文件，下面给出一个例子用于创建多彩方块：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;minecraft:crafting_shaped&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span></span><br><span class="line">  <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;ddd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;dgd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;ddd&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;d&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;forge:gems/diamond&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;g&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;item&quot;</span><span class="punctuation">:</span> <span class="string">&quot;minecraft:gold_ingot&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;item&quot;</span><span class="punctuation">:</span> <span class="string">&quot;examplemod:colorful_block&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">8</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p> 这个配方创建了多彩方块，使用8个钻石和1个金锭，最终结果为：</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140133135.png" alt="image-20220305181944349"></p><h2 id="各个json名分析"><a href="#各个json名分析" class="headerlink" title="各个json名分析"></a>各个json名分析</h2><ul><li>type:分为无序和有序合成，如无序，则为<code>minecraft:crafting_shapeless</code>，如有序，则为<code>minecraft:crafting_shaped</code> 这些为默认的合成配方，你也可以自定义自己的合成配方，日后可能会介绍</li><li>pattern:在有序合成中为每个物品放置的位置，如果你需要2*2的，直接将行和列改成2*2即可，里面的字母在后面的key中有说明</li><li>key:每个key代表pattern代表的是什么物品，可能注意到有两个注释，一个为item，一个为tag，item比较好理解，就是物品，tag则为标签，在文章后面会介绍</li><li>result：输出结果，item为输出物品，count为多少个</li></ul><p> 下面为无序合成的标签</p><ul><li>ingredients:为一个数组，里面直接写item或者tag，案例：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;ingredients&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;item&quot;</span><span class="punctuation">:</span> <span class="string">&quot;minecraft:diamond&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;item&quot;</span><span class="punctuation">:</span> <span class="string">&quot;minecraft:glod_ingot&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p> 在上面已经看到了合成表中可以是用标签来代替item，这一章将会介绍如何创建自己的标签以及使用原版中存在的标签</p><h3 id="创建自己的标签"><a href="#创建自己的标签" class="headerlink" title="创建自己的标签"></a>创建自己的标签</h3><p> 在<code>./data/&#123;modid&#125;/tags/</code>文件夹下新建blocks和items文件夹，分别放置方块和物品的标签，接下来在items中创建<code>useful_items.json</code>，对于blocks标签暂不创建，接下来在里面写入:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;replace&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;examplemod:redstone_ingot&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p> 这样就创建了一个新的标签，为useful_items（虽然并不是），里面含有我们的红石锭，json标签的意思为：</p><ul><li>replace：替换之前加入的这一类标签的物体，之前注册在这一标签的都会被删除，默认为false，建议默认就好</li><li>values：一个数组，里面为需要加入该标签的物体，id为物体id，required为是否需要，如果找不到该物体，并且require没有写为false则会报错</li></ul><h3 id="使用原版标签"><a href="#使用原版标签" class="headerlink" title="使用原版标签"></a>使用原版标签</h3><p> 在<code>./data/minecraft/tags/</code>文件夹下新建blocks和items文件夹，用于分别放置方块和物品标签，接下来在blocks中创建<code>mineable_pickaxe.json</code>,暂不加入items标签，接下来在里面写入</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;replace&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;examplemod:colorful_block&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p> 这样就将我们的多彩方块加入了原版标签<code>mineable_pickle</code>中，所有原版标签请看<a href="https://minecraft.fandom.com/wiki/Tag#List_of_tags">这个链接</a>，如这个文件所示，可以直接用名字代表物体id，不需要加required，但required默认为true</p><p> 在游戏内按F3，对准多彩方块，在右边应该就能看到多彩方块多了一个<code>#minecraft:mineable_pickaxe</code>，表示标签添加成功了</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140134019.png" alt="image-20220305201155676"></p><h3 id="在代码中使用标签"><a href="#在代码中使用标签" class="headerlink" title="在代码中使用标签"></a>在代码中使用标签</h3><p> 先上代码，上面一行代表代表使用自己的标签，下面的两行代表获得该item的标签，为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Tag.Named&lt;Item&gt; USEFUL_ITEMS = ItemTags.bind(<span class="string">&quot;examplemod:useful_items&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// In some method</span></span><br><span class="line"><span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> stack.getItem();</span><br><span class="line">Set&lt;ResourceLocation&gt; tags = item.getTags();</span><br></pre></td></tr></table></figure><p> 这样即可使用自己的标签等，forge文档给出了一个方法为item.is({tag})来判断某个item在不在某个标签内，但我试的时候貌似没这个方法，只有一个getTags用于获得所有标签</p>]]></content>
      
      
      <categories>
          
          <category> 我的世界mod开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的世界mod开发 </tag>
            
            <tag> forge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的世界1.18mod开发学习(7)-网络</title>
      <link href="/2022/02/22/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(7)-%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/02/22/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(7)-%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p> 在这一章将会讲述我的世界中有关网络的应用，将会添加一个新的物品，客户端使用这个物品与服务端进行通信</p><h3 id="创建新物品"><a href="#创建新物品" class="headerlink" title="创建新物品"></a>创建新物品</h3><p> 首先需要创建一个新的物品，在这里我不提供代码，只提供一个<a href="https://i.postimg.cc/FHCDwjzT/remote-control.png">物品材质</a>以及物品的名字:RemoteControl（java类等记得命名为这个，方便后续说明），当运行完后具体的界面应该为：</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140133795.png" alt="image-20220226192412617"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p> 首先需要创建文件名为MyMessageHandler，放在examplemod&#x2F;network下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMessageHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROTOCOL_VERSION</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleChannel</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> NetworkRegistry.newSimpleChannel(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ResourceLocation</span>(Reference.MOD_ID,<span class="string">&quot;main&quot;</span>),</span><br><span class="line">            ()-&gt;PROTOCOL_VERSION,</span><br><span class="line">            PROTOCOL_VERSION::equals,</span><br><span class="line">            PROTOCOL_VERSION::equals</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送给一个玩家</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendOnePlayer</span><span class="params">(ServerPlayer serverPlayer,IMessage message)</span>&#123;</span><br><span class="line">        INSTANCE.send(PacketDistributor.PLAYER.with(()-&gt;serverPlayer),message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送给一个世界的区块的人</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendToLevelChunk</span><span class="params">(LevelChunk levelChunk, IMessage message)</span>&#123;</span><br><span class="line">        INSTANCE.send(PacketDistributor.TRACKING_CHUNK.with(()-&gt;levelChunk),message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送消息给所有的人</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendAll</span><span class="params">(IMessage message)</span>&#123;</span><br><span class="line">        INSTANCE.send(PacketDistributor.ALL.noArg(),message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务器发包（客户端到服务器）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessageToServer</span><span class="params">(IMessage msg)</span> &#123;</span><br><span class="line">        INSTANCE.sendToServer(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息给一个点周围的人</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sendToAllAround</span><span class="params">(IMessage message, PacketDistributor.TargetPoint point)</span> &#123;</span><br><span class="line">        INSTANCE.send(PacketDistributor.NEAR.with(() -&gt; point), message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span>&#123;</span><br><span class="line">        INSTANCE.registerMessage(addId(), PlayerEventPacket.class, PlayerEventPacket::encode, PlayerEventPacket::decode, PlayerEventPacket::handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其次创建IMessage接口以及PlayerEventPacket类，同样在network下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMessage</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlayerEventPacket</span> <span class="keyword">implements</span> <span class="title class_">IMessage</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(PlayerEventPacket msg, FriendlyByteBuf buf)</span> &#123;</span><br><span class="line">        buf.writeBoolean(msg.isActivate);</span><br><span class="line">        buf.writeUUID(msg.uuid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> PlayerEventPacket <span class="title function_">decode</span><span class="params">(FriendlyByteBuf buf)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PlayerEventPacket</span>(buf.readUUID(),buf.readBoolean());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="keyword">final</span> PlayerEventPacket msg, Supplier&lt;NetworkEvent.Context&gt; contextSupplier)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> NetworkEvent.<span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> contextSupplier.get();</span><br><span class="line">        ctx.enqueueWork(() -&gt; ExampleMod.proxy.handlePlayerEventPacket(msg,ctx.getSender()));</span><br><span class="line">        ctx.setPacketHandled(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> isActivate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> UUID uuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PlayerEventPacket</span><span class="params">(UUID uuid,<span class="type">boolean</span> isActivate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isActivate = isActivate;</span><br><span class="line">        <span class="built_in">this</span>.uuid = uuid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 修改proxy下的CommonProxy，ClientProxy与ServerProxy，分别添加一个方法，从上往下为Common,Client,Server</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlePlayerEventPacket</span><span class="params">(PlayerEventPacket msg, ServerPlayer player)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlePlayerEventPacket</span><span class="params">(PlayerEventPacket msg, ServerPlayer player)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(msg.isActivate)&#123;</span><br><span class="line">        LOGGER.atInfo().log(Minecraft.getInstance().player.getName().getContents()+<span class="string">&quot; is activate&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        LOGGER.atInfo().log(Minecraft.getInstance().player.getName().getContents()+<span class="string">&quot; is not activate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlePlayerEventPacket</span><span class="params">(PlayerEventPacket msg,ServerPlayer player)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Boolean[] isActivate = <span class="keyword">new</span> <span class="title class_">Boolean</span>[<span class="number">1</span>];</span><br><span class="line">    LazyOptional&lt;IPlayer&gt; capability = player.getCapability(SuperPlayer.CAPABILITY);</span><br><span class="line">    capability.ifPresent((cap) -&gt; &#123;</span><br><span class="line">        isActivate[<span class="number">0</span>] = cap.isActivated();</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatcher.sendOnePlayer(player,<span class="keyword">new</span> <span class="title class_">PlayerEventPacket</span>(msg.uuid,isActivate[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 在ClientProxy上添加LOGGER，为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LogManager.getLogger();</span><br></pre></td></tr></table></figure><p> 最后，在ExampleMod添加&#x2F;覆盖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MyMessageHandler</span> <span class="variable">dispatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyMessageHandler</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ExampleMod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">    dispatcher.register();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="MyMessageHandler"><a href="#MyMessageHandler" class="headerlink" title="MyMessageHandler"></a>MyMessageHandler</h4><p> 这一个类为最重要的一个类，forge将网络抽象成了消息队列，MyMessageHandler中的INSTANCE即为创建了一个简单的通信，通过这个可以与服务端&#x2F;客户端进行通信，上方的PROTOCOL_VERSION为你定义的通信协议版本，不同版本会拒绝访问</p><p> 在类中的方法上面已经写好了发送消息的解释，最下面的register为注册消息类，每个消息类需要一个唯一的id传入，在这里可以直接id++。消息类需要传入一个静态的编码，解码，和处理的方法</p><h4 id="PlayerEventPacket"><a href="#PlayerEventPacket" class="headerlink" title="PlayerEventPacket"></a>PlayerEventPacket</h4><ul><li>encode: 将一个消息写入缓存中</li><li>decode：从缓存中取出内容</li><li>handle：当接收到消息后，如何对消息进行处理，在这里是直接交给了代理</li></ul><p> 备注：IMessage只是用来抽象消息类的，方便定义自己的消息</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p> 不同端需要不同的代理，在服务端（物理）中的代理为ServerProxy,在这里对消息的处理是发送给发送方关于他是否激活的信息，在客户端（物理）中的代理为ClientProxy,在这里获得了玩家名字以及消息中的是否激活，直接打印出来</p><h4 id="主类中的dispatcher"><a href="#主类中的dispatcher" class="headerlink" title="主类中的dispatcher"></a>主类中的dispatcher</h4><p> 主类中的dispatcher是方便在模组其他地方发送消息</p><h3 id="流程讲解"><a href="#流程讲解" class="headerlink" title="流程讲解"></a>流程讲解</h3><p>大致流程：</p><ol><li>客户端右击遥控器，发送消息给服务端（在这里其实消息内部不需要东西，可以新建一个专门用于客户端请求数据的消息类）</li><li>服务端接收到消息，发送客户端请求的数据（在这里为是否激活以及玩家uuid）给客户端</li><li>客户端接收到消息，打印到控制台中</li></ol><p>消息发送流程（以物品使用这个过程为例，发送和接受）:</p><ol><li>物品被使用，调用了sendToServer</li><li>sendToServer使用encode，将数据写入缓存中，发送给服务端</li><li>服务端接收到消息，调用decode，提取缓存内容到一个消息类中</li><li>解码(decode)后，调用handler对接收到的数据进行处理（在这里可以是用enqueueWork，这个将会在之后的某个时间调用里面的方法）</li></ol><h3 id="给物品添加发送消息功能"><a href="#给物品添加发送消息功能" class="headerlink" title="给物品添加发送消息功能"></a>给物品添加发送消息功能</h3><p> 将以下代码放入RemoteControl中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> InteractionResultHolder&lt;ItemStack&gt; <span class="title function_">use</span><span class="params">(Level level, Player player, InteractionHand hand)</span> &#123;</span><br><span class="line">    LazyOptional&lt;IPlayer&gt; capability = player.getCapability(SuperPlayer.CAPABILITY);</span><br><span class="line">    capability.ifPresent((cap) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(level.isClientSide)&#123;</span><br><span class="line">            ExampleMod.dispatcher.sendMessageToServer(<span class="keyword">new</span> <span class="title class_">PlayerEventPacket</span>(player.getUUID(),cap.isActivated()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> InteractionResultHolder.consume(player.getMainHandItem());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 加入后同时运行两个端，一个服务端一个客户端</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140133562.png" alt="image-20220226201324780"></p><p> 运行其中的runServer和runClient，推荐以Debug形式运行，运行后客户端需要加入127.0.0.1:25565，加入后记得服务端给op权限: &#x2F;op xxx</p><p> 右击新物品Remote Control，能在runClient看见一个消息，如果在服务端的数据中，玩家已经被激活，则是Dev is activate，如果没有激活，则为 Dev is not activate，其中的Dev为客户端玩家名字，一般来讲跑的时候是Dev</p><h3 id="一些坑及有趣的地方"><a href="#一些坑及有趣的地方" class="headerlink" title="一些坑及有趣的地方"></a>一些坑及有趣的地方</h3><p> 在学习过程时在ClientProxy中打印是否激活的方法里头，我直接使用了本地的player，导致是否激活和服务端不匹配，后来发现，这个数据并没有被同步，所有数据应该为服务端发送，客户端接受，客户端不应对一些世界数据进行操作，在给玩家一些物品，buff等也应判断是否是服务端</p><p> 在Server运行时，在ServerProxy中的<code>handlePlayerEventPacket</code>加个断点，右击遥控器，然后你就会发现在客户端里头世界仿佛停止了，这就跟在玩多人游戏时，卡或者突然断网一个道理</p>]]></content>
      
      
      <categories>
          
          <category> 我的世界mod开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的世界mod开发 </tag>
            
            <tag> forge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的世界1.18mod开发学习(6)-数据存储</title>
      <link href="/2022/02/21/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(6)-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
      <url>/2022/02/21/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(6)-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<p> 本来打算直接介绍Block Entities，但看了下源代码，还是先需要介绍数据存储 :)</p><h2 id="NBT"><a href="#NBT" class="headerlink" title="NBT"></a>NBT</h2><p> 我的世界中存在一个NBT系统，通过标签（Tag）来存储和读取数据，一个标签由标签名和数值两部分组成，格式为name:data，中间不能有空格，中文或是特殊符号，name对大小写敏感。一串标签（name:data)拼接在一起并用{}包括称之为NBT，比如{damage:3,speed:2}，有点像json格式。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p> 这一部分主要列出了Tag类型，先介绍简单的Tag，以及复合Tag</p><ul><li><p>整型Tag:</p><ul><li><p><code>ByteTag</code>：字节Tag，用于存储一字节（8bit）</p></li><li><p><code>ShortTag</code>：Short类型Tag，用于存储两字节（16bit）</p></li><li><p><code>IntTag</code>：Int类型Tag，用于存储4字节（32bit）</p></li><li><p><code>LongTag</code>：Long类型Tag，用于存储8字节（64bit）</p></li></ul></li><li><p>浮点数Tag:</p><ul><li><code>FloatTag</code>：Float类型Tag，用于存储浮点数，4字节（32bit）</li><li><code>DoubleTag</code>：Double类型Tag，用于存储浮点数，8字节（64bit）</li></ul></li><li><p><code>StringTag</code>：用于保存字符串</p></li><li><p>集合类Tag：</p><ul><li><code>ListTag</code>：用于存储一系列Tag（相同类型），如果为CompoundTag，则每个复合类型的子标签名要一致</li><li><code>ByteArrayTag</code>：用于存储多个Byte Tag</li><li><code>IntArrayTag</code>：用于存储多个Int Tag</li><li><code>LongArrayTag</code>：用于存储多个Long Tag</li></ul></li><li><p><code>CompoundTag</code>：包含一段独立的NBT标签，存储多个不同Tag</p></li></ul><p>Tag的格式等详见<a href="https://minecraft.fandom.com/zh/wiki/%E6%95%99%E7%A8%8B/NBT%E5%91%BD%E4%BB%A4%E6%A0%87%E7%AD%BE#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">这里</a>使用的比较多的应该是<code>CompoundTag</code></p><h2 id="Capability"><a href="#Capability" class="headerlink" title="Capability"></a>Capability</h2><p> 首先来看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Capability</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nonnull</span> &lt;R&gt; LazyOptional&lt;R&gt; <span class="title function_">orEmpty</span><span class="params">(Capability&lt;R&gt; toCheck, LazyOptional&lt;T&gt; inst)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span> == toCheck ? inst.cast() : LazyOptional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRegistered</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.listeners == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Capability&lt;T&gt; <span class="title function_">addListener</span><span class="params">(Consumer&lt;Capability&lt;T&gt;&gt; listener)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isRegistered())</span><br><span class="line">            listener.accept(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">this</span>.listeners.add(listener);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    List&lt;Consumer&lt;Capability&lt;T&gt;&gt;&gt; listeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Capability(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onRegister</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">listeners</span> <span class="operator">=</span> <span class="built_in">this</span>.listeners;</span><br><span class="line">        <span class="built_in">this</span>.listeners = <span class="literal">null</span>;</span><br><span class="line">        listeners.forEach(l -&gt; l.accept(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以看到里面有一个叫做Consumer，这个是用来传输函数的，调用accept即可调用传进的函数，有一个参数，不需要返回值，当调用了onRegister后Capability将会调用这个函数</p><p> 在这里我将不会先介绍如何使用他定义好的Capability，而是先介绍如何创建自己的Capability，并将他注册到游戏内不知道如何创建自己的而去直接用他的可能会比较困难，在这里我们会将这个Capability赋予玩家，并利用之前的写好的红石锭激活这个Capability（注意是利用Capability里面的自定义布尔激活），并且赋予玩家一个加速效果。新建一个接口，名为IPlayer放在examplemod&#x2F;player下，在相同路径player下创建一个类叫做SuperPlayer，并implement IPlayer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPlayer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">activate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Boolean <span class="title function_">isActivated</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">loadData</span><span class="params">(CompoundTag nbt)</span>;</span><br><span class="line"></span><br><span class="line">    CompoundTag <span class="title function_">saveData</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperPlayer</span> <span class="keyword">implements</span> <span class="title class_">IPlayer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IS_ACTIVATE_STRING</span> <span class="operator">=</span> <span class="string">&quot;isActivate&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_TICK</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ResourceLocation</span> <span class="variable">SUPER_PLAYER_KEY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceLocation</span>(Reference.MOD_ID,<span class="string">&quot;super_player&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isActivated</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Capability&lt;IPlayer&gt; CAPABILITY = CapabilityManager.get(<span class="keyword">new</span> <span class="title class_">CapabilityToken</span>&lt;&gt;()&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperPlayer</span><span class="params">()</span>&#123;</span><br><span class="line">        MinecraftForge.EVENT_BUS.register(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ICapabilityProvider <span class="title function_">createNewCapability</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ICapabilitySerializable</span>&lt;CompoundTag&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@NotNull</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; LazyOptional&lt;T&gt; <span class="title function_">getCapability</span><span class="params">(<span class="meta">@NotNull</span> Capability&lt;T&gt; cap, <span class="meta">@org</span>.jetbrains.annotations.Nullable Direction side)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> CAPABILITY.orEmpty(cap, opt);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">IPlayer</span> <span class="variable">inst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperPlayer</span>();</span><br><span class="line">            <span class="keyword">final</span> LazyOptional&lt;IPlayer&gt; opt = LazyOptional.of(() -&gt; inst);</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deserializeNBT</span><span class="params">(CompoundTag nbt)</span> &#123;</span><br><span class="line">                ((SuperPlayer)inst).loadData(nbt);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> CompoundTag <span class="title function_">serializeNBT</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ((SuperPlayer)inst).saveData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">activate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.isActivated = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">isActivated</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isActivated;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadData</span><span class="params">(CompoundTag nbt)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isActivated = nbt.getBoolean(IS_ACTIVATE_STRING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SubscribeEvent</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTickUpdate</span><span class="params">(TickEvent.PlayerTickEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(event.side== LogicalSide.SERVER&amp;&amp;tickCount++&gt;UPDATE_TICK) &#123;</span><br><span class="line">            tickCount = <span class="number">0</span>;</span><br><span class="line">            <span class="type">Player</span> <span class="variable">player</span> <span class="operator">=</span> event.player;</span><br><span class="line">            LazyOptional&lt;IPlayer&gt; capability;</span><br><span class="line">            <span class="keyword">if</span> (player == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            capability = player.getCapability(CAPABILITY, <span class="literal">null</span>);</span><br><span class="line">            capability.ifPresent((cap) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (cap.isActivated()) &#123;</span><br><span class="line">                    <span class="comment">//necessary</span></span><br><span class="line">                    player.addEffect(<span class="keyword">new</span> <span class="title class_">MobEffectInstance</span>(MobEffects.MOVEMENT_SPEED,</span><br><span class="line">                            <span class="number">200</span>, <span class="number">3</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompoundTag <span class="title function_">saveData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CompoundTag</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompoundTag</span>();</span><br><span class="line">        tag.putBoolean(IS_ACTIVATE_STRING,isActivated);</span><br><span class="line">        <span class="keyword">return</span> tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 添加AttachHandler到handler下，修改RedstoneIngot，添加<code>new AttachHandler();</code>到ExampleMod下的init()函数中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AttachHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AttachHandler</span><span class="params">()</span>&#123;</span><br><span class="line">        MinecraftForge.EVENT_BUS.register(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SubscribeEvent</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAttachCapability</span><span class="params">(AttachCapabilitiesEvent&lt;Entity&gt; event)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getObject() <span class="keyword">instanceof</span> Player) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                event.addCapability(SuperPlayer.SUPER_PLAYER_KEY, SuperPlayer.createNewCapability());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedstoneIngot</span> <span class="keyword">extends</span> <span class="title class_">ItemBase</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedstoneIngot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;redstone_ingot&quot;</span>, <span class="keyword">new</span> <span class="title class_">Item</span>.Properties().tab(ExampleMod.creativeTab));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InteractionResultHolder&lt;ItemStack&gt; <span class="title function_">use</span><span class="params">(Level level, Player player, InteractionHand hand)</span> &#123;</span><br><span class="line">        LazyOptional&lt;IPlayer&gt; capability = player.getCapability(SuperPlayer.CAPABILITY);</span><br><span class="line">        capability.ifPresent((cap) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (!level.isClientSide&amp;&amp;!cap.isActivated()) &#123;</span><br><span class="line">                <span class="comment">//necessary</span></span><br><span class="line">                cap.activate();</span><br><span class="line">                player.getMainHandItem().setCount(player.getMainHandItem().getCount()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> InteractionResultHolder.consume(player.getMainHandItem());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这样一来，进入游戏后右击红石锭，就会发现获得了一个速度效果，kill后会发现效果消失了，需要重新建立，这就是因为我们没有订阅 PlayerEvent.Clone 事件来达成kill后依旧有原来的效果，我们先分析上面修改的几个类</p><ul><li><code>IPlayer</code>：用于定义一个玩家的接口，用于激活和获得激活状态</li><li><code>RedstoneIngot</code>：用于右击后激活超级玩家</li><li><code>AttachHandler</code>：添加Capability到玩家内，就像注册物品，方块一样，Capability也需要注册到各种实体内，就比如玩家</li></ul><p><strong>SuperPlayer</strong></p><p> 具体实现的（超级）玩家，其中的几个变量具体为：</p><ul><li><code>IS_ACTIVATE_STRING</code>：是否激活的名字，因为保存的Tag需要一个名字</li><li><code>UPDATE_TICK</code>：更新时间，80一般代表80&#x2F;20&#x3D;4s</li><li><code>SUPER_PLAYER_KEY</code>：用于添加Capability时对应的key，如果不知道key和value是什么，请参考java的Map</li><li><code>tickCount</code>：用于计tick数</li><li><code>isActivated</code>：用于判断玩家是否激活</li><li><code>CAPABILITY</code>：用于生成一个Capability，生成Capability只需要使用CapabilityManager.get(new CapabilityToken&lt;&gt;(){});即可，注意Capability&lt;?&gt;中的？为你的接口&#x2F;类，CapabilityManager.get方法貌似是获取了你的接口或类的相对路径，然后根据这个路径来判断是否是重复</li></ul><p> 里面的函数具体解释：（不会解释比较短的函数）</p><ul><li><code>createNewCapability</code>：用于创建一个新的Capability，里面创建的具体函数为<ol><li>判断是否是自己</li><li>从NBT中读取数据，转化为自己的属性（即加载数据）</li><li>从自身的数据转化为NBT（即保存数据）</li></ol></li><li><code>onTickUpdate</code>：用于每个玩家Tick的更新，如果激活则会给予玩家速度效果</li></ul><h3 id="使用forge功能以及添加"><a href="#使用forge功能以及添加" class="headerlink" title="使用forge功能以及添加"></a>使用forge功能以及添加</h3><p> Forge提供了三个接口，用于规范，具体使用方法即为新建Capability时，讲IPlayer替换为下列接口名</p><ul><li><code>IItemHandler</code>：用于处理库存的接口，可以应用于BlockEntities、Entities或ItemStacks</li><li><code>IFluidHandler</code>：用于处理流体库存的接口，可以应用于BlockEntities、Entities或ItemStacks</li><li><code>IEnergyStorage</code>：用于处理能量容器的接口，可以应用于BlockEntities、Entities或ItemStacks</li></ul><p>名词举例：</p><ul><li><code>BlockEntities</code>（箱子、机器）</li><li><code>Entities</code>（玩家、生物）</li><li><code>ItemStacks</code>（便携式背包）</li></ul><p> Capability可以添加到<code>Entity</code>、<code>BlockEntity</code>、<code>ItemStack</code>、<code>Level</code>、<code>LevelChunk</code>中，具体为订阅以下事件：</p><ul><li><code>AttachCapabilitiesEvent&lt;Entity&gt;</code>：对实体触发。</li><li><code>AttachCapabilitiesEvent&lt;BlockEntity&gt;</code>：对方块实体触发。</li><li><code>AttachCapabilitiesEvent&lt;ItemStack&gt;</code>：对物品堆叠触发。</li><li><code>AttachCapabilitiesEvent&lt;Level&gt;</code>：针对关卡触发。</li><li><code>AttachCapabilitiesEvent&lt;LevelChunk&gt;</code>：对关卡块触发。</li></ul><h3 id="持久化与同步"><a href="#持久化与同步" class="headerlink" title="持久化与同步"></a>持久化与同步</h3><p> 对于持久化（保存到磁盘中）Capability，请参见<a href="https://mcforge.readthedocs.io/en/1.18.x/datastorage/capabilities/#persisting-levelchunk-and-blockentity-capabilities">这里</a></p><p> 对于数据的同步，主要是需要Server同步给Client，在forge文档内写出了一些场景需要同步（网络会单独出一章）</p><ol><li>当实体在世界中生成或放置块时</li><li>当存储的数据发生变化时</li><li>当新客户端开始查看实体或块时</li></ol><p> 默认状态下，玩家死亡时不会同步Capability，如果要同步需要订阅<code>PlayerEvent.Clone</code>事件，<a href="https://mcforge.readthedocs.io/en/1.18.x/datastorage/capabilities/#persisting-across-player-deaths">参考</a>，这里我给出了一个例子，将下面代码添加到AttachHandler中运行游戏即可发现死亡后依旧有能力了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SubscribeEvent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPlayerClone</span><span class="params">(PlayerEvent.Clone event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!event.getPlayer().getCommandSenderWorld().isClientSide&amp;&amp;event.isWasDeath()) &#123;</span><br><span class="line">        <span class="type">SuperPlayer</span> <span class="variable">player</span> <span class="operator">=</span> (SuperPlayer) event.getPlayer().getCapability(SuperPlayer.CAPABILITY).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot get Super player capability from player &quot;</span> + event.getPlayer()));</span><br><span class="line">        event.getOriginal().reviveCaps();</span><br><span class="line">        <span class="type">SuperPlayer</span> <span class="variable">oldPlayer</span> <span class="operator">=</span> (SuperPlayer) event.getOriginal().getCapability(SuperPlayer.CAPABILITY).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot get Super player capability from player &quot;</span> + event.getOriginal()));</span><br><span class="line">        event.getOriginal().invalidateCaps();</span><br><span class="line">        player.loadData(oldPlayer.saveData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在这一版本中，重生还需要有能力需要调用player中的<code>reviveCaps</code>，得到原来的后在调用<code>invalidateCaps</code>，之前弄的时候貌似不用导致现在出错..折腾了我蛮久 :(</p><h2 id="保存世界数据"><a href="#保存世界数据" class="headerlink" title="保存世界数据"></a>保存世界数据</h2><p> 如果你需要保存数据到世界中，则需要 implement SavedData，在这里需要创建一个类名为WorldSaveData，并保存在examplemod&#x2F;world下，需要修改RedstoneIngot用于修改物品时设置数据为脏数据，这样之后就会自动保存。首先是WorldSaveData</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorldSaveData</span> <span class="keyword">extends</span> <span class="title class_">SavedData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;UUID, IPlayer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DATA_KEY</span> <span class="operator">=</span> <span class="string">&quot;example_world_data&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">ID</span> <span class="operator">=</span> <span class="string">&quot;example-data&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    <span class="keyword">private</span> WorldSaveData <span class="title function_">getData</span><span class="params">(<span class="keyword">final</span> MinecraftServer server)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> server.getLevel(Level.OVERWORLD).getDataStorage().computeIfAbsent(<span class="built_in">this</span>::load, <span class="built_in">this</span>::create, ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> WorldSaveData <span class="title function_">create</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;WorldSaveData&gt; <span class="title function_">getData</span><span class="params">(LevelAccessor world)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (world <span class="keyword">instanceof</span> ServerLevel) &#123;</span><br><span class="line">            <span class="type">WorldSaveData</span> <span class="variable">worldSaveData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorldSaveData</span>();</span><br><span class="line">            <span class="keyword">return</span> Optional.of(worldSaveData.getData(((ServerLevel) world).getServer()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyPlayer</span><span class="params">(Player player)</span>&#123;</span><br><span class="line">        LazyOptional&lt;IPlayer&gt; capability = player.getCapability(SuperPlayer.CAPABILITY);</span><br><span class="line">        capability.ifPresent((cap) -&gt; &#123;</span><br><span class="line">            map.put(player.getUUID(),cap);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> WorldSaveData <span class="title function_">load</span><span class="params">(CompoundTag nbt)</span> &#123;</span><br><span class="line">        <span class="type">WorldSaveData</span> <span class="variable">worldSaveData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorldSaveData</span>().create();</span><br><span class="line">        <span class="type">Tag</span> <span class="variable">tag1</span> <span class="operator">=</span> nbt.get(DATA_KEY);</span><br><span class="line">        <span class="keyword">if</span>(tag1 <span class="keyword">instanceof</span> ListTag)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Tag tag : (ListTag) tag1) &#123;</span><br><span class="line">                <span class="type">CompoundTag</span> <span class="variable">compoundTag</span> <span class="operator">=</span> (CompoundTag) tag;</span><br><span class="line">                <span class="type">UUID</span> <span class="variable">name</span> <span class="operator">=</span> compoundTag.getUUID(<span class="string">&quot;uuid&quot;</span>);</span><br><span class="line">                <span class="type">SuperPlayer</span> <span class="variable">superPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperPlayer</span>();</span><br><span class="line">                superPlayer.loadData(compoundTag);</span><br><span class="line">                worldSaveData.map.put(name, superPlayer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> worldSaveData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompoundTag <span class="title function_">save</span><span class="params">(CompoundTag p_77763_)</span> &#123;</span><br><span class="line">        <span class="type">ListTag</span> <span class="variable">listTag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListTag</span>();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;UUID,IPlayer&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="type">CompoundTag</span> <span class="variable">compoundTag</span> <span class="operator">=</span> entry.getValue().saveData();</span><br><span class="line">            compoundTag.putUUID(<span class="string">&quot;uuid&quot;</span>,entry.getKey());</span><br><span class="line">            listTag.add(compoundTag);</span><br><span class="line">        &#125;</span><br><span class="line">        p_77763_.put(DATA_KEY,listTag);</span><br><span class="line">        <span class="keyword">return</span> p_77763_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以及需要将RedstoneIngot中的use进行修改，激活后需要保存玩家数据（默认貌似不会保存，也应不需要保存）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> InteractionResultHolder&lt;ItemStack&gt; <span class="title function_">use</span><span class="params">(Level level, Player player, InteractionHand hand)</span> &#123;</span><br><span class="line">    LazyOptional&lt;IPlayer&gt; capability = player.getCapability(SuperPlayer.CAPABILITY);</span><br><span class="line">    capability.ifPresent((cap) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!level.isClientSide&amp;&amp;!cap.isActivated()) &#123;</span><br><span class="line">            <span class="comment">//necessary</span></span><br><span class="line">            cap.activate();</span><br><span class="line">            player.getMainHandItem().setCount(player.getMainHandItem().getCount()-<span class="number">1</span>);</span><br><span class="line">            Optional&lt;WorldSaveData&gt; data = WorldSaveData.getData(level);</span><br><span class="line">            data.ifPresent((worldSaveData)-&gt;&#123;</span><br><span class="line">                worldSaveData.setDirty();</span><br><span class="line">                worldSaveData.modifyPlayer(player);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> InteractionResultHolder.consume(player.getMainHandItem());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 如此就能达到保存游戏数据的目的，现在进行分析，主要是针对WorldSaveData，RedstoneIngot中只调整了玩家以及设置了数据块为脏，从上到下为代码中变量和方法出现的顺序，方法带有()</p><ul><li><code>map</code>：用于存储玩家信息，一个玩家有一个唯一的UUID，利用他来存储，value为玩家信息</li><li><code>DATA_KEY</code>：用于声明自己存储的ListTag的名字</li><li><code>ID</code>：用于声明自己存储的文件名</li><li><code>getData()</code>：用于获得一个存储实例，这边暂时没有分析，只有<a href="https://mcforge.readthedocs.io/en/1.18.x/datastorage/saveddata/#attaching-to-a-level">forge文档的说明</a></li><li><code>create()</code>：用于传递给getData()的方法，新建了一个自己</li><li><code>static getData()</code>：用于给全局获取一个存储实例，这样自己可以存储一些信息</li><li><code>modifyPlayer()</code>：修改玩家信息，用于全局获取存储实例后调用</li><li><code>load()</code>：从CompoundTag中获取自己存储的信息</li><li><code>save()</code>：往CompoundTag中写入自己要存储的数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 我的世界mod开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的世界mod开发 </tag>
            
            <tag> forge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的世界1.18mod开发学习(5)-Block</title>
      <link href="/2022/02/20/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(5)-Block/"/>
      <url>/2022/02/20/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(5)-Block/</url>
      
        <content type="html"><![CDATA[<h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><p> 方块是我的世界最重要的一部分，在这一篇将介绍如何新建一个方块，注册，然后是材质加载，材质随便画了一个，称为多彩方块(colorful_block)好了</p><h3 id="新建一个方块"><a href="#新建一个方块" class="headerlink" title="新建一个方块"></a>新建一个方块</h3><p> 首先来看Block的构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Block</span><span class="params">(BlockBehaviour.Properties p_49795_)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(p_49795_);</span><br><span class="line">    StateDefinition.Builder&lt;Block, BlockState&gt; builder = <span class="keyword">new</span> <span class="title class_">StateDefinition</span>.Builder&lt;&gt;(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.createBlockStateDefinition(builder);</span><br><span class="line">    <span class="built_in">this</span>.stateDefinition = builder.create(Block::defaultBlockState, BlockState::<span class="keyword">new</span>);</span><br><span class="line">    <span class="built_in">this</span>.registerDefaultState(<span class="built_in">this</span>.stateDefinition.any());</span><br><span class="line">    <span class="keyword">if</span> (SharedConstants.IS_RUNNING_IN_IDE) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getSimpleName();</span><br><span class="line">        <span class="keyword">if</span> (!s.endsWith(<span class="string">&quot;Block&quot;</span>)) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;Block classes should end with Block and &#123;&#125; doesn&#x27;t.&quot;</span>, (Object)s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    initClient();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以看到，如果需要新建一个Block，需要传入一个<code>BlockBehaviour.Properties</code>，Properties内含方块的一些属性，比如是否能碰撞，爆炸抗性，破坏时间等，这里只介绍最简单的创建方法，其他的均为默认，新建一个类名为Dust，创建完毕后即创建好并且注册到了游戏内，在给的代码框架内中的<code>BlockBase</code>，已经自动的添加到了<code>ModBlocks.BLOCKS</code>和<code>BLOCK_ITEMS</code>等待进一步注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColorfulBlock</span> <span class="keyword">extends</span> <span class="title class_">BlockBase</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ColorfulBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;colorful_block&quot;</span>, BlockBehaviour.Properties.of(Material.DIRT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 别忘了在<code>ModBlocks</code>中添加以下代码实例化方块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Block</span> <span class="variable">COLORFUL_BLOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorfulBlock</span>();</span><br></pre></td></tr></table></figure><h3 id="注册到游戏内"><a href="#注册到游戏内" class="headerlink" title="注册到游戏内"></a>注册到游戏内</h3><p> Block与Item不同，Item注册完后可以直接看到，Block除了注册自身，还需要注册一个叫做BlockItem，在给出的代码中RegistryHandler中的<code>onRegisterItems</code>中可以看到除了注册Item还注册了ItemBlock，在这个方法内注册了所有的BlockItem</p><p> 在我的世界中，放置在世界里的叫做Block，在物品栏或者其他存储内的应为Item，为了让Block和Item有联系，存在一个类叫做BlockItem，这个类继承了Item，并且内含一个block用于存储自己所属的Block，BlockItem实现方块放置等方法，新建一个Block时，默认不包含一个BlockItem，因此除了注册Block，还需注册BlockItem</p><h4 id="创建BlockItem"><a href="#创建BlockItem" class="headerlink" title="创建BlockItem"></a>创建BlockItem</h4><p> 构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BlockItem</span><span class="params">(Block p_40565_, Item.Properties p_40566_)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(p_40566_);</span><br><span class="line">    <span class="built_in">this</span>.block = p_40565_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中super代表Item，在这里可以发现，需要传入Block，以及<code>Item.Properties</code>来创建一个BlockItem，在BlockBase中自动添加进了ModBlock内的<code>BLOCK_ITEMS</code>等待注册</p><p>**有关<code>CreativeTab</code>**（创造模式物品栏）</p><p> 在代码框架中的ExampleMod已经创建了一个最简单的创造模式物品栏，最简单的CreativeModeTab创建方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CreativeModeTab</span> <span class="variable">creativeModeTab</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreativeModeTab</span>(模组id) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemStack <span class="title function_">makeIcon</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemStack</span>(Items.DIAMOND);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="材质及语言"><a href="#材质及语言" class="headerlink" title="材质及语言"></a>材质及语言</h3><p> 进入游戏后大概率会发现这个物体没有名字，只有一长串的字符，并且无论是拿在手里的还是实际放出的都是紫黑块，那是因为还没有定义他的名字以及材质</p><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><p> assets&#x2F;examplemod&#x2F;lang下的en_us.json中加入（别忘了逗号）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;block.examplemod.colorful_block&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Colorful Block&quot;</span></span><br></pre></td></tr></table></figure><p> 接着登录游戏就能看到他的名字变成了Colorful Block</p><h4 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h4><p> 首先，需要确保你存在路径src&#x2F;main&#x2F;resources&#x2F;assets&#x2F;examplemod&#x2F;</p><ul><li>blockstates</li><li>models&#x2F;block</li><li>models&#x2F;item</li><li>textures&#x2F;block</li></ul><p> 如果不存在，请创建，并且需要准备一张16*16 png格式的像素图，保存在textures&#x2F;block下，这里提供了<a href="https://i.postimg.cc/6ptqbrS2/teach.png">一张</a>，用Aseprite随便画的，命名为colorful_block.png</p><p> 在models&#x2F;block中创建文件colorful_block.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;block/cube_all&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;textures&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;all&quot;</span><span class="punctuation">:</span> <span class="string">&quot;examplemod:block/colorful_block&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p> 在models&#x2F;item下创建文件colorful_block.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;examplemod:block/colorful_block&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>进入游戏，会发现手上的方块已经有材质了，但是放下来后依旧是紫黑块，接下来创建的文件会解决这个问题，在blockstates下创建文件colorful_block.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;variants&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;examplemod:block/colorful_block&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p> 再次进入游戏，应该就能发现紫黑块有材质了（虽然有点丑）</p><h3 id="BlockBench"><a href="#BlockBench" class="headerlink" title="BlockBench"></a>BlockBench</h3><p> 推荐一个用来建立我的世界方块的工具，BlockBench,这个工具会根据你创建的模型自动生成你需要的json文件，这里暂时不补充，有兴趣的可以去试试</p><h2 id="BlockState"><a href="#BlockState" class="headerlink" title="BlockState"></a>BlockState</h2><p> 我的世界1.7及以前的版本中，需要存储状态的块使用的是metadata(元数据，来自翻译），其是与块一起存储的额外数字，可以通过定义metadata来进行一些其他的操作</p><p> 但是metadata不看源码或没注释的话是纯粹的魔法数字，没人看得懂，因此从1.8开始，BlockState取代了之前的metadata，在forge文档中举了个例子，朝东，并且激活状态的石头按钮的存储</p><p> 原本为”minecraft:stone_button”，元数据为9</p><p> 现在为”minecraft:stone_button[facing&#x3D;east,powered&#x3D;true]”</p><p> 第二种更为实用，对于BlockState，每一种状态组合在游戏创建初期就已经确认，不可变，因此可以用(&#x3D;&#x3D;)来检查两个状态是否相等</p><h3 id="如何创建一种状态属性"><a href="#如何创建一种状态属性" class="headerlink" title="如何创建一种状态属性"></a>如何创建一种状态属性</h3><p> 官方已经给好了四种基本状态，为</p><ul><li><code>IntegerProperty</code></li><li><code>DirectionProperty</code></li><li><code>EnumProperty</code></li><li><code>BooleanProperty</code></li></ul><p> 分别是整数属性，方向属性，Enum属性，布尔属性，需要创建这些类型的可以直接new，对于他们各自的构造方法在此不细究，<a href="https://mcforge.readthedocs.io/en/1.18.x/blocks/states/#implementing-block-states">官方文档</a>给的较为详细</p><p> 如果需要创建自己的状态，需要继承Property&lt;?&gt;类，在这里面实现一些方法，具体实现可以参考源码的实现完成的属性</p><h3 id="注册到Block中"><a href="#注册到Block中" class="headerlink" title="注册到Block中"></a>注册到Block中</h3><p> 当确定需要一个状态时，需要覆写<code>createBlockStateDefinition(StateDefinition.Builder)</code>来加入，通过调用<code>registerDefaultState</code>来改变默认状态，在这里同样使用之前的first_block，但是改为了一个类，在这里给出覆写以及更改默认状态后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColorfulBlock</span> <span class="keyword">extends</span> <span class="title class_">BlockBase</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BooleanProperty</span> <span class="variable">BOOLEAN_PROPERTY</span> <span class="operator">=</span> BooleanProperty.create(<span class="string">&quot;example_boolean&quot;</span>);;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ColorfulBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;colorful_block&quot;</span>, BlockBehaviour.Properties.of(Material.DIRT));</span><br><span class="line">        <span class="built_in">this</span>.registerDefaultState(</span><br><span class="line">                <span class="built_in">this</span>.stateDefinition.any()</span><br><span class="line">                        .setValue(BOOLEAN_PROPERTY, <span class="literal">false</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">createBlockStateDefinition</span><span class="params">(StateDefinition.Builder&lt;Block, BlockState&gt; stateBuilder)</span> &#123;</span><br><span class="line">        stateBuilder.add(BOOLEAN_PROPERTY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 如果需要覆盖放置块时的BlockState，可以通过覆写<code>getStateForPlacement</code>方法，默认为方块的默认状态，写完后在游戏内按F3，对着方块在右边即可看到有一个<code>example_boolean:false</code></p><h3 id="与blockstates中的json文件交互"><a href="#与blockstates中的json文件交互" class="headerlink" title="与blockstates中的json文件交互"></a>与blockstates中的json文件交互</h3><p> 在ColorfulBlock中覆写<code>getStateForPlacement</code>语句，这样能修改放置下来的布尔属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> BlockState <span class="title function_">getStateForPlacement</span><span class="params">(BlockPlaceContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(context.getClickedPos().getX()%<span class="number">2</span>==<span class="number">0</span>||context.getClickedPos().getZ()%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> defaultBlockState().setValue(BOOLEAN_PROPERTY,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultBlockState().setValue(BOOLEAN_PROPERTY,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 意思为只有X和Z坐标为单数时，布尔属性为false，下面修改blockstates中的colorful_block.json为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;variants&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;example_boolean=true&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;examplemod:block/colorful_block&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;example_boolean=false&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;minecraft:block/oak_log&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>设置完成后，进入游戏即可看到，当X和Z坐标为单数时，模型变为了橡木原木，其他模型不变（当然，如果你是加入语句之前放置的，之前的方块依旧为false，也就会渲染成橡木）</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140132139.png" alt="image-20220221093606267"></p><p> 除了简单的判断example_boolean，还有其他的方法来判断多种属性(when… apply)，以及设置旋转，材质锁定等，具体见<a href="https://minecraft.fandom.com/wiki/Model#Block_states">此链接</a></p><h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><p> 源码中的Block继承了BlockBehaviour，在里面有很多的交互方法以及获取一些值，forge文档中给出了不少例子可以作为<a href="https://mcforge.readthedocs.io/en/1.18.x/blocks/interaction/#block-interaction">参考</a></p><p> 在此处只打出这些方法名，可以通过网页搜索看看有没有需要的，日后可能会拓展其中一些</p><ul><li><code>attack</code></li><li><code>canBeReplaced</code></li><li><code>canSurvive</code></li><li><code>defaultDestroyTime</code></li><li><code>defaultMaterialColor</code></li><li><code>entityInside</code></li><li><code>getAnalogOutputSignal</code></li><li><code>getBlockSupportShape</code></li><li><code>getCollsionShape</code></li><li><code>getDirectSignal</code></li><li><code>getDrops</code></li><li><code>getFluidState</code></li><li><code>getInteractionShape</code></li><li><code>getLightBlock</code></li><li><code>getLootTable</code></li><li><code>getMaxHorizontalOffset</code></li><li><code>getMaxVerticalOffset</code></li><li><code>getMenuProvider</code></li><li><code>getOcclusionShape</code></li><li><code>getOffsetType</code></li><li><code>getPistonPushReaction</code></li><li><code>getRenderShape</code></li><li><code>getSeed</code></li><li><code>getShadeBrightness</code></li><li><code>getShape</code></li><li><code>getSignal</code></li><li><code>getVisualShape</code></li><li><code>hasAnalogOutputSignal</code></li><li><code>isAir</code></li><li><code>isCollsionShapeFullBlock</code></li><li><code>isPathfindable</code></li><li><code>isSignalSource</code></li><li><code>mirror</code></li><li><code>neighborChanged</code></li><li><code>onPlace</code></li><li><code>onProjectileHit</code></li><li><code>onRemove</code></li><li><code>randomTick</code></li><li><code>rotate</code></li><li><code>skipRendering</code></li><li><code>spawnAfterBreak</code></li><li><code>tick</code></li><li><code>triggerEvent</code></li><li><code>updateIndirectNeighbourShapes</code></li><li><code>updateShape</code></li><li><code>use</code></li><li><code>useShapeForLightOcclusion</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 我的世界mod开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的世界mod开发 </tag>
            
            <tag> forge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的世界1.18mod开发学习(4)-Item</title>
      <link href="/2022/02/19/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(4)-Item/"/>
      <url>/2022/02/19/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(4)-Item/</url>
      
        <content type="html"><![CDATA[<h2 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h2><p> 这一章将会正式开始写代码，往游戏内注册第一个物品，我们将以红石锭(redstone_ingot)为例</p><h3 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h3><p> 在items下创建RedstoneIngot类并继承ItemBase，构造方法修改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RedstoneIngot</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;redstone_ingot&quot;</span>, <span class="keyword">new</span> <span class="title class_">Item</span>.Properties().tab(ExampleMod.creativeTab));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在ModItems中新建一个RedstoneIngot</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Item</span> <span class="variable">REDSTONE_INGOT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedstoneIngot</span>();</span><br></pre></td></tr></table></figure><p> 此时进入游戏应该能看见在你的创造栏内有一个物品，名应该为<code>item.examplemod.redstone_ingot</code>，这是因为我们还没有添加其他的属性，比如语言，材质，模型等</p><h3 id="添加语言，材质"><a href="#添加语言，材质" class="headerlink" title="添加语言，材质"></a>添加语言，材质</h3><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><p> 在assets&#x2F;examplemod&#x2F;lang下寻找en_us.json，在里面添加一句</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;item.examplemod.redstone_ingot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Redstone Ingot&quot;</span></span><br></pre></td></tr></table></figure><p> 注意到前面的名字是与你之前拿在手里的字符串相同，再次启动游戏就能发现物品已经有名字</p><h4 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h4><p> 在assets&#x2F;examplemod&#x2F;item下创建文件，名为redstone_ingot.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">    <span class="attr">&quot;parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/generated&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="attr">&quot;textures&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    </span><br><span class="line">        <span class="attr">&quot;layer0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;examplemod:item/redstone_ingot&quot;</span>  </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这个文件只是描述了模型，除此之外还需要一个材质图片，在此我找到了运算工艺<a href="https://i.mcmod.cn/item/icon/128x128/4/43479.png">红石锭</a>的图片，下载保存在textures&#x2F;item下，命名为redstone_ingot.png，此时进入游戏就能发现手中的物品拥有了材质，如果这个物品没有特殊作用就不用在进行操作了</p><h2 id="给予属性"><a href="#给予属性" class="headerlink" title="给予属性"></a>给予属性</h2><p> 现在你的物品什么也不能做，所以接下来把他变成可以食用的红石锭吧！通过修改RedstoneIngot的构造方法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RedstoneIngot</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;redstone_ingot&quot;</span>, <span class="keyword">new</span> <span class="title class_">Item</span>.Properties().tab(ExampleMod.creativeTab)</span><br><span class="line">          .food(<span class="keyword">new</span> <span class="title class_">FoodProperties</span>.Builder().alwaysEat().fast()</span><br><span class="line">                .effect(<span class="keyword">new</span> <span class="title class_">MobEffectInstance</span>(MobEffects.MOVEMENT_SPEED,</span><br><span class="line">                                              <span class="number">1200</span>,<span class="number">3</span>),<span class="number">1</span>).nutrition(<span class="number">10</span>).saturationMod(<span class="number">20.0f</span>).build()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 即可将你的红石锭变为可食用的，不仅随时随地能吃，吃的飞快，还给予了速度4的效果！这些是通过修改<code>Item.Properties</code>实现的，如果想要实现更多功能，可以修改其他的属性，或者覆写函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> InteractionResultHolder&lt;ItemStack&gt; <span class="title function_">use</span><span class="params">(Level level, Player player, InteractionHand hand)</span> &#123;</span><br><span class="line">    player.giveExperiencePoints(<span class="number">100</span>);</span><br><span class="line">    player.getMainHandItem().setCount(player.getMainHandItem().getCount()-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> InteractionResultHolder.consume(player.getMainHandItem());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加此段到RedstoneIngot类中，运行游戏就右击红石锭就可以发现使用后会增加经验</p>]]></content>
      
      
      <categories>
          
          <category> 我的世界mod开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的世界mod开发 </tag>
            
            <tag> forge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的世界1.18mod开发学习(3)-概念</title>
      <link href="/2022/02/18/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(3)-%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/02/18/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(3)-%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p> 你关注了一个微信公众号，微信公众号发文章时会通知你有新文章了，你阅读了新文章后可能会做某些操作比如评论，点赞等</p><p> 在上面场景中，微信公众号发布新文章是一个事件，关注微信公众号就是订阅了这个事件，通知你时代表调用了你的一个函数来通知，新文章代表的是在这个事件包含的内容（参数），做出的某些操作就是你在这个函数中的操作，场景可以简化为：</p><ol><li>关注公众号</li><li>公众号发布新文章</li><li>通知你</li><li>做出操作</li></ol><p> 如果替换成事件，则为：</p><ol><li>订阅事件</li><li>事件发生</li><li>调用你在订阅时给出的函数</li><li>你在函数内做出操作</li></ol><p> 详细可以参考<a href="https://www.runoob.com/design-pattern/observer-pattern.html">观察者模式</a></p><h3 id="Forge中的事件"><a href="#Forge中的事件" class="headerlink" title="Forge中的事件"></a>Forge中的事件</h3><p> 大概分为两条线，一个是游戏中的事件线，一个是模组事件线</p><h4 id="游戏事件线"><a href="#游戏事件线" class="headerlink" title="游戏事件线"></a>游戏事件线</h4><p> 如攻击实体，与实体交互等事件</p><h4 id="模组事件线"><a href="#模组事件线" class="headerlink" title="模组事件线"></a>模组事件线</h4><p><a href="https://mcforge.readthedocs.io/en/1.18.x/events/intro/#mod-event-bus">点我</a></p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><h4 id="调用的函数定义方法"><a href="#调用的函数定义方法" class="headerlink" title="调用的函数定义方法"></a>调用的函数定义方法</h4><p> 在函数前加上注解 @SubscribeEvent，参数名为你要订阅的事件，如我想要订阅TickEvent.PlayerTickEvent则函数为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SubscribeEvent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTick</span><span class="params">(TickEvent.PlayerTickEvent playerTickEvent)</span> &#123;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何注册函数"><a href="#如何注册函数" class="headerlink" title="如何注册函数"></a>如何注册函数</h4><p> 有两种方法来注册你的函数</p><h5 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h5><p> 对于游戏事件线，使用MinecraftForge.EVENT_BUS.register({Class})来将这个类注册进事件系统，其中的Class可以为静态也可以new一个，如果是静态的则需要将你要传递的函数设为static，不过为new，则将static去除，下面给出了两个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubsucribeExample</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubsucribeExample</span><span class="params">()</span>&#123;</span><br><span class="line">        MinecraftForge.EVENT_BUS.register(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SubscribeEvent</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTick</span><span class="params">(TickEvent.PlayerTickEvent playerTickEvent)</span> &#123;</span><br><span class="line">        <span class="comment">//do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubsucribeExample</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubsucribeExample</span><span class="params">()</span>&#123;</span><br><span class="line">        MinecraftForge.EVENT_BUS.register(SubsucribeExample.class);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SubscribeEvent</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">onTick</span><span class="params">(TickEvent.PlayerTickEvent playerTickEvent)</span> &#123;</span><br><span class="line">        <span class="comment">//do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 对于模组事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMLJavaModLoadingContext.get().getModEventBus().addListener(&#123;函数名&#125;);</span><br></pre></td></tr></table></figure><p> 即可注册函数，不用在函数前加上@SubscribeEvent，或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMLJavaModLoadingContext.get().getModEventBus().register(&#123;类名&#125;);</span><br></pre></td></tr></table></figure><p> 同样也要注意静态问题</p><h5 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h5><p> 在整个类前加入@Mod.EventBusSubscriber注解，注解源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@interface</span> EventBusSubscriber &#123;</span><br><span class="line">    Dist[] value() <span class="keyword">default</span> &#123; Dist.CLIENT, Dist.DEDICATED_SERVER &#125;;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">modid</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Bus <span class="title function_">bus</span><span class="params">()</span> <span class="keyword">default</span> Bus.FORGE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Bus</span> &#123;</span><br><span class="line">        FORGE(Bindings.getForgeBus()),</span><br><span class="line">        MOD(()-&gt; FMLJavaModLoadingContext.get().getModEventBus());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;IEventBus&gt; busSupplier;</span><br><span class="line"></span><br><span class="line">        Bus(<span class="keyword">final</span> Supplier&lt;IEventBus&gt; eventBusSupplier) &#123;</span><br><span class="line">            <span class="built_in">this</span>.busSupplier = eventBusSupplier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Supplier&lt;IEventBus&gt; <span class="title function_">bus</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> busSupplier;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读源码可知，value的值为物理服务端还是物理客户端，或者两者均可，modid为你的模组id，bus为你要订阅的事件线，FORGE为游戏事件线，MOD为模组事件线，通过配置这三者可以达到你想要的目的</p><p> 需要注意的是，通过这种方法注册，函数需要都是static</p><h3 id="事件的一些属性"><a href="#事件的一些属性" class="headerlink" title="事件的一些属性"></a>事件的一些属性</h3><h4 id="能否取消"><a href="#能否取消" class="headerlink" title="能否取消"></a>能否取消</h4><p> 通过调用event中的isCancelable()函数来得到当前事件是否能被取消，或者阅读源码查看是否有@Cancelable注解，有即为可以取消，函数返回true，否即没有，如果需要取消事件，可以调用setCanceled(boolean canceled)来决定是否取消事件，不能取消一个不可取消的事件，否则会崩溃</p><h4 id="事件结果"><a href="#事件结果" class="headerlink" title="事件结果"></a>事件结果</h4><p> 有一些事件有结果，比如树苗长为大树事件，官方注解中提到</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/202211140132331.png" alt="image-20220218184541813"></p><p> 通过调用setResult（Result result）来返回一个结果，可以调用hasResult()来判断该事件是否有结果，有些没有有些有</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p> @SubscribeEvent的注解具有优先级，可以通过设置priority值来设置处理优先级，可以为</p><ul><li>HIGHEST</li><li>HIGH</li><li>NORMAL</li><li>LOW</li><li>LOWEST</li></ul><p> 从上到下代表优先级从高到底，优先级高的会先执行（默认NORMAL）</p><h4 id="子事件"><a href="#子事件" class="headerlink" title="子事件"></a>子事件</h4><p> 如果你订阅了一个父事件，比如PlayerEvent，则他属下的所有事件发生时都会触发你的函数</p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p> 在之前提到了游戏需要添加物品，方块等，在这里称为注册物品，需要注册物品才能让游戏知道有这个物品。</p><h3 id="根据什么注册"><a href="#根据什么注册" class="headerlink" title="根据什么注册"></a>根据什么注册</h3><p> 注册物品通常用使用的是ResourceLocation来注册，在实例化一个物品时通过setRegistryName来设置ResourceLocation，也可以实例化后再自己设置，注意的是只能设置一次，使用getRegistryName来获取。</p><p> 如果一个Block和一个Item的ResourceLocation内名字相同，不会冲突，但如果不同的Item使用了同一个namespace和path，则最后注册的将会覆盖第一个</p><h3 id="如何注册"><a href="#如何注册" class="headerlink" title="如何注册"></a>如何注册</h3><h4 id="DeferredRegister"><a href="#DeferredRegister" class="headerlink" title="DeferredRegister"></a>DeferredRegister</h4><p>官方文档给出的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DeferredRegister&lt;Block&gt; BLOCKS = DeferredRegister.create(ForgeRegistries.BLOCKS, MODID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Block&gt; ROCK_BLOCK = BLOCKS.register(<span class="string">&quot;rock&quot;</span>, () -&gt; <span class="keyword">new</span> <span class="title class_">Block</span>(BlockBehaviour.Properties.of(Material.STONE)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ExampleMod</span><span class="params">()</span> &#123;</span><br><span class="line">    BLOCKS.register(FMLJavaModLoadingContext.get().getModEventBus());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Register事件"><a href="#Register事件" class="headerlink" title="Register事件"></a>Register事件</h4><p>通过订阅Register事件来注册物品，如果是注册Block，则为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SubscribeEvent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBlocks</span><span class="params">(RegistryEvent.Register&lt;Block&gt; event)</span> &#123;</span><br><span class="line">    event.getRegistry().registerAll(<span class="keyword">new</span> <span class="title class_">Block</span>(...), <span class="keyword">new</span> <span class="title class_">Block</span>(...), ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是Item，则为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SubscribeEvent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerItems</span><span class="params">(RegistryEvent.Register&lt;Item&gt; event)</span> &#123;</span><br><span class="line">    event.getRegistry().registerAll(<span class="keyword">new</span> <span class="title class_">Item</span>(...), <span class="keyword">new</span> <span class="title class_">Item</span>(...), ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下待补充…</p><h3 id="怎么引用"><a href="#怎么引用" class="headerlink" title="怎么引用"></a>怎么引用</h3><p> 第一种方法为使用RegistryObject，第二种方法为@ObjectHolder，这些在注册完物品后会更新</p><h4 id="RegistryObject"><a href="#RegistryObject" class="headerlink" title="RegistryObject"></a>RegistryObject</h4><p> 官方的例子比较好地说明了如何使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;Item&gt; BOW = RegistryObject.of(<span class="keyword">new</span> <span class="title class_">ResourceLocation</span>(<span class="string">&quot;minecraft:bow&quot;</span>), ForgeRegistries.ITEMS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// assume that ManaType is a valid registry, and &#x27;neomagicae:coffeinum&#x27; is a valid object within that registry</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RegistryObject&lt;ManaType&gt; COFFEINUM = RegistryObject.of(<span class="keyword">new</span> <span class="title class_">ResourceLocation</span>(<span class="string">&quot;neomagicae&quot;</span>, <span class="string">&quot;coffeinum&quot;</span>), () -&gt; ManaType.class); </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>java</p><p>使用RegistryObject.of(ResourceLocation，游戏中的某个东西)</p><h4 id="ObjectHandler"><a href="#ObjectHandler" class="headerlink" title="@ObjectHandler"></a>@ObjectHandler</h4><p> 官方的规则较为复杂..在这只放出一些使用案例，由于后面注释过长，因此想要看原来的<a href="https://mcforge.readthedocs.io/en/1.18.x/concepts/registries/#using-objectholder">点这</a>，在此只会说明注入的namespace和路径，如果没有诸如成功，则会注释其他</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ObjectHolder(&quot;minecraft&quot;)</span> <span class="comment">// namespace: minecraft</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnnotatedHolder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Block</span> <span class="variable">diamond_block</span> <span class="operator">=</span> <span class="literal">null</span>;   <span class="comment">// minecraft:diamond_block</span></span><br><span class="line">    <span class="meta">@ObjectHolder(&quot;ambient.cave&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">SoundEvent</span> <span class="variable">ambient_sound</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">// minecraft:ambient.cave</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assume for the next entry that [ManaType] is a valid registry.          </span></span><br><span class="line">    <span class="meta">@ObjectHolder(&quot;neomagicae:coffeinum&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ManaType</span> <span class="variable">coffeinum</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">// neomagicae:coffeinum</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Item</span> <span class="variable">ENDER_PEARL</span> <span class="operator">=</span> <span class="literal">null</span>;      <span class="comment">// minecraft:ender_pearl</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ObjectHolder(&quot;minecraft:arrow&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ArrowItem</span> <span class="variable">arrow</span> <span class="operator">=</span> <span class="literal">null</span>;       <span class="comment">// minecraft:arrow                                             </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Block</span> <span class="variable">bedrock</span> <span class="operator">=</span> <span class="literal">null</span>;               <span class="comment">// 没有final，获得不成功</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CreativeModeTab</span> <span class="variable">group</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 没有对应的Registry，所以会抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnannotatedHolder</span> &#123; <span class="comment">// 注意到没有注解</span></span><br><span class="line">    <span class="meta">@ObjectHolder(&quot;minecraft:flame&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Enchantment</span> <span class="variable">flame</span> <span class="operator">=</span> <span class="literal">null</span>;     <span class="comment">// minecraft:flame</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Biome</span> <span class="variable">ice_flat</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="comment">// 没获得</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ObjectHolder(&quot;minecraft:creeper&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Entity</span> <span class="variable">creeper</span> <span class="operator">=</span> <span class="literal">null</span>;              <span class="comment">// Entity没有对应的Registry，会抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ObjectHolder(&quot;levitation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Potion</span> <span class="variable">levitation</span> <span class="operator">=</span> <span class="literal">null</span>;     <span class="comment">// 没有namespace，抛出异常，没获得</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体有没有对应的Registry参考 net.minecraftforge.registries.ForgeRegistries。也可以自定义Registry，如上面代码中的ManaType</p><h3 id="创建自己的Registry"><a href="#创建自己的Registry" class="headerlink" title="创建自己的Registry"></a>创建自己的Registry</h3><p> 要创建自己的Registry，首先要实现IForgeRegistryEntry，其中定义了setRegistryName和getRegistryName，官方推荐继承ForgeRegistryEntry，其中有默认的实现</p><h4 id="将自己的Registry注册到游戏中"><a href="#将自己的Registry注册到游戏中" class="headerlink" title="将自己的Registry注册到游戏中"></a>将自己的Registry注册到游戏中</h4><p> 首先需要一个类继承了ForgeRegistryEntry或者实现了IForgeRegistryEntry</p><p> 订阅RegistryEvent.NewRegistry，经过测试，这一行代码能顺利注册自己的Registry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IForgeRegistry&lt;ManaType&gt; manaTypes = <span class="keyword">new</span> <span class="title class_">RegistryBuilder</span>&lt;ManaType&gt;().setName(<span class="keyword">new</span> <span class="title class_">ResourceLocation</span>(<span class="string">&quot;examplemod:mana_type&quot;</span>)).setType(ManaType.class).create();</span><br></pre></td></tr></table></figure><p> 其中的manaTypes变量最好保存，他只是做个例子，你可以自定义自己的registry，比如技能等，setName和setType是必须的，还有其他的函数诸如setMaxID等。实测不加入setName可以注册成功，可以进入我的世界那个界面，但进入世界时会崩溃，所以需要setName</p><h3 id="处理不存在的registry-object"><a href="#处理不存在的registry-object" class="headerlink" title="处理不存在的registry object"></a>处理不存在的registry object</h3><p> 当mod更新时，可能会删除或者加入一些物品，对于那些删除的物品，可以通过订阅RegistryEvent.MissingMappings来解决删除物品的问题，具体见<a href="https://mcforge.readthedocs.io/en/1.18.x/concepts/registries/#handling-missing-entries">此</a></p><h2 id="模组生命周期"><a href="#模组生命周期" class="headerlink" title="模组生命周期"></a>模组生命周期</h2><p> 模组加载过程中，各种生命周期事件会在特定的事件总线（FMLJavaModLoadingContext.get().getModEventBus()）上触发，比如注册对象，准备数据等</p><h3 id="注册表事件"><a href="#注册表事件" class="headerlink" title="注册表事件"></a>注册表事件</h3><p> 在mod被实例化后会被触发，有两个事件，NewRegistry和Register事件，NewRegistry即为创建自定义Registry，Register使用方法之前提到了，例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SubscribeEvent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerItems</span><span class="params">(RegistryEvent.Register&lt;Item&gt; event)</span> &#123;</span><br><span class="line">    event.getRegistry().registerAll(<span class="keyword">new</span> <span class="title class_">Item</span>(...), <span class="keyword">new</span> <span class="title class_">Item</span>(...), ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h3><p> 待补充</p><h3 id="一般设置"><a href="#一般设置" class="headerlink" title="一般设置"></a>一般设置</h3><p> 事件为FMLCommonSetupEvent，在物理服务端和物理客户端中都会被触发，比如注册capabilities（后期会提到）</p><h3 id="不同端的设置"><a href="#不同端的设置" class="headerlink" title="不同端的设置"></a>不同端的设置</h3><p> 对于物理客户端，事件为FMLClientSetupEvent，对于物理服务端，事件为FMLDedicatedServerSetupEvent</p><h3 id="跨模组交流"><a href="#跨模组交流" class="headerlink" title="跨模组交流"></a>跨模组交流</h3><p> 两个事件：</p><ul><li>InterModEnqueueEvent</li><li>InterModProcessEvent</li></ul><p> 第一个事件为向不同mod发送消息，第二个事件为接受不同消息，发送和接受参考InterModComms类，包为net.minecraftforge.fml</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p> 还有两个生命周期事件</p><ul><li>FMLConstructModEvent，在mod实例化之后，RegistryEvent之前触发</li><li>FMLLoadCompleteEvent，在InterModComms（跨模组交流）后触发</li></ul>]]></content>
      
      
      <categories>
          
          <category> 我的世界mod开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的世界mod开发 </tag>
            
            <tag> forge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的世界1.18mod开发学习(2)-概念</title>
      <link href="/2022/02/17/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(2)-%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/02/17/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(2)-%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="服务端-x2F-客户端"><a href="#服务端-x2F-客户端" class="headerlink" title="服务端&#x2F;客户端"></a>服务端&#x2F;客户端</h2><p>首先，要了解服务端和客户端这两者代表着什么</p><ul><li>客户端就是你正在玩的那个游戏，有丰富的图形，你的键盘鼠标的移动能带来游戏界面的变化。</li><li>服务端是用来连接多人游戏的地方，如果连接过我的世界服务器就应该能知道，游玩前需要输入一串数字或英文字母来连接到一个服务器，服务端就是运行在服务器（同样是一台电脑，但是与普通电脑会有点区别）上的一个程序，服务端一般没有丰富的图形界面，只有通过命令的形式交互</li><li>多人游戏就是多个客户端连接到一个服务端</li><li>顺带一提，就算是单人游戏也创建了一个服务端</li></ul><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p> 在forge官方文档中再将服务端和客户端进行了划分，分为</p><ul><li>物理客户端：客户端进程，也就是你打开客户端exe后那整个程序</li><li>物理服务端：服务端进程，与物理客户端类似，但没有一个丰富的图形界面来游玩（搭建过的应该都知道）</li><li>逻辑服务端：用于控制天气，生物生成，生物的ai等等，在单人游戏里，一个物理客户端可以包含一个逻辑服务端以及一个逻辑客户端</li><li>逻辑客户端：接受玩家的输入，如键盘鼠标等，并反馈给逻辑服务端以及渲染，同时也接受逻辑服务端的内容进行渲染</li></ul><h3 id="不同的端需要进行不同的操作"><a href="#不同的端需要进行不同的操作" class="headerlink" title="不同的端需要进行不同的操作"></a>不同的端需要进行不同的操作</h3><p> 在Level这个类下，有一个布尔类型的值isClientSide，通过这个布尔值可以判断当前是逻辑客户端(true)还是逻辑服务端(false)</p><p> 对于逻辑服务端和逻辑客户端需要进行不同的操作，我的理解是，如果需要对玩家或者世界数据等进行修改，确保不在逻辑客户端。比如破坏方块对世界进行了修改，则需要确保不在逻辑客户端中运行了破坏逻辑</p><h4 id="分开调用"><a href="#分开调用" class="headerlink" title="分开调用"></a>分开调用</h4><p> 物理客户端不能调用 net.minecraft.server.dedicated 下的类，物理服务端不能调用 net.minecraft.client 下的类，否则会导致崩溃，Dist用于区分是物理客户端还是物理服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Dist</span> &#123;   </span><br><span class="line">    </span><br><span class="line">    CLIENT,    </span><br><span class="line">    DEDICATED_SERVER;   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDedicatedServer</span><span class="params">()</span>    &#123;        <span class="keyword">return</span> !isClient();    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isClient</span><span class="params">()</span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span> == CLIENT;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单人游戏中逻辑服务端和逻辑客户端都会使用Dist. CLIENT</strong></p><h4 id="单面模组（不需要双方都有）"><a href="#单面模组（不需要双方都有）" class="headerlink" title="单面模组（不需要双方都有）"></a>单面模组（不需要双方都有）</h4><p> 有些例子如失落的城市，只是世界生成，并没有新的方块等，所以可以直接放到逻辑服务端，通过添加以下代码（官方给的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModLoadingContext.get().registerExtensionPoint(IExtensionPoint. DisplayTest.class, () -&gt; <span class="keyword">new</span> <span class="title class_">IExtensionPoint</span>. DisplayTest(() -&gt; NetworkConstants. IGNORESERVERONLY, (a, b) -&gt; <span class="literal">true</span>)); </span><br></pre></td></tr></table></figure><p> 服务端和客户端的区分蛮多的..</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p> 分为两个，一个是用于视觉的，放在逻辑客户端上，称为assets，一个是用于玩法的，放在逻辑服务端上，称为data，assets由资源包控制，data由客户端控制，默认情况下，assets和data在src&#x2F;main&#x2F;resources下，需要确保你的assets和data路径下都是蛇形命名，单词间以_分割，比如iron_ingot代表铁锭</p><h4 id="ResourceLocation"><a href="#ResourceLocation" class="headerlink" title="ResourceLocation"></a>ResourceLocation</h4><p> 这个为类，具体在前面的文章介绍过，现在直接复制过来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceLocation</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String namespace;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ResourceLocation</span><span class="params">(String[] p_135814_)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.namespace = StringUtils.isEmpty(p_135814_[<span class="number">0</span>]) ? <span class="string">&quot;minecraft&quot;</span> : p_135814_[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.path = p_135814_[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!isValidNamespace(<span class="built_in">this</span>.namespace)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ResourceLocationException</span>(<span class="string">&quot;Non [a-z0-9_.-] character in namespace of location: &quot;</span> + <span class="built_in">this</span>.namespace + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.path);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isValidPath(<span class="built_in">this</span>.path)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ResourceLocationException</span>(<span class="string">&quot;Non [a-z0-9/._-] character in path of location: &quot;</span> + <span class="built_in">this</span>.namespace + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResourceLocation</span><span class="params">(String p_135809_)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(decompose(p_135809_, <span class="string">&#x27;:&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResourceLocation</span><span class="params">(String p_135811_, String p_135812_)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;p_135811_, p_135812_&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 截取了一部分源码，其中有namespace和path，可以认为前面的是命名空间，为mod id，后面为你为这个方块&#x2F;物品命名的名字。两者通过: 合并，如我的世界中泥土这两者应为minecraft以及dirt，这一点可以通过IDEA debug认证：</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/image-1.png" alt="image-1"></p><p> 可以看见namespace为minecraft，path为dirt，合在一起为minecraft:dirt</p><h4 id="在哪"><a href="#在哪" class="headerlink" title="在哪"></a>在哪</h4><p> 通常需要将材质放置在assets&#x2F;“namespace”&#x2F;“ctx”&#x2F;“path”下，namespace和path为ResourceLocation里对应的字符串，ctx为一个特定的路径，放一张截图作为参考:</p><p><img src="http://typora-upload-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220217231624620.png" alt="image-20220217231624620"></p><p> 父目录为namespace，截图来自吸血鬼模组的assets，如果你现在要添加一个物品叫做铁匕首（iron_dagger），命名空间为mod id叫做 examplemod，则models下的item需要放置一个json文件作为描述这个材质内容，接着在textures下的item放置你的具体材质图片，如json文件为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">    <span class="attr">&quot;parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item/generated&quot;</span><span class="punctuation">,</span>   </span><br><span class="line">    <span class="attr">&quot;textures&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    </span><br><span class="line">        <span class="attr">&quot;layer0&quot;</span><span class="punctuation">:</span> <span class="string">&quot;examplemod:item/iron_dagger&quot;</span>  </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p> 则需要在textures下创建一个item文件夹（此处的文件夹名与上方json里的layer0那一行的item相同），里面放置你的材质图片并命名为iron_dagger.png，此处只举例了item，还有诸如Block等</p><h2 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h2><p> 官方文档没怎么说明，日后自己需要开发时会补充</p><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p> 我的世界的语言界面由许多的语言，在这里将介绍如何写国际化的语言（英语）以及本地化（中文）</p><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p> 位于assets&#x2F;“namespace”&#x2F;lang&#x2F;“locale”.json，比如namespace为examplemod，locale为中文，则路径为assets&#x2F;examplemod&#x2F;lang&#x2F;zh_cn.json</p><p>locale:</p><ul><li>英文:en_us</li><li>中文:zh_cn</li></ul><p> 官方给出的样例:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">    <span class="attr">&quot;item.examplemod.example_item&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Example Item Name&quot;</span><span class="punctuation">,</span>   </span><br><span class="line">    <span class="attr">&quot;block.examplemod.example_block&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Example Block Name&quot;</span><span class="punctuation">,</span>   </span><br><span class="line">    <span class="attr">&quot;commands.examplemod.examplecommand.error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Example Command Errored!&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p> examplemod为mod id，需要注意的是，注册不同类型的，比如方块和物品，前缀会不一样</p><p> 可以通过覆写getOrCreateDescriptionId来建立你的，比如在Item中，默认的为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String <span class="title function_">getOrCreateDescriptionId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.descriptionId == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.descriptionId = Util.makeDescriptionId(<span class="string">&quot;item&quot;</span>, Registry.ITEM.getKey(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.descriptionId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以通过覆写为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">getOrCreateDescriptionId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.translation_key == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.translation_key = Util.makeDescriptionId(<span class="string">&quot;item&quot;</span>, <span class="built_in">this</span>.getRegistryName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.translation_key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">getOrCreateDescriptionId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.translation_key == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.translation_key = Util.makeDescriptionId(<span class="string">&quot;items&quot;</span>, <span class="built_in">this</span>.getRegistryName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.translation_key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果覆写成了第二种，当你继承你写的这个类并添加item时，翻译应为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">    <span class="attr">&quot;items.examplemod.example_item&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Example Item Name&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 我的世界mod开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的世界mod开发 </tag>
            
            <tag> forge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的世界1.18mod开发学习(1)-环境搭建</title>
      <link href="/2022/02/17/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(1)-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/02/17/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C1.18mod%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(1)-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>由于源码解读记录没有一个能跟随的流程，因此源码解读记录将会转变为阅读<a href="https://mcforge.readthedocs.io/en/1.18.x/">forge官方文档</a></p></li><li><p>因为是一边学习一边做记录，未来可能会修改或者添加更多的内容</p></li><li><p>有一些阅读时认为不太需要的不会记录，不一定会跟着官方文档</p></li><li><p>有时候阅读别的模组源码或许会给新的思路</p></li><li><p>需要有点java基础</p></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p> 本篇主要是介绍环境搭建，以及一些框架搭建</p><h3 id="下载及配置"><a href="#下载及配置" class="headerlink" title="下载及配置"></a>下载及配置</h3><p> 配置使用的操作系统为Windows，配置gradlew时使用的是java 1.8.0_221，运行minecraft时使用的是openjdk-17，IDE为IDEA</p><p> <a href="https://files.minecraftforge.net/net/minecraftforge/forge/">官方网站</a>，点进去下载Mdk版本，我下的时候是1.18.1-39.0.79，下载完毕后，在目录下打开控制台（cmd）输入gradlew xxx，需要注意你的IDE是什么，xxx为下面中的一个:</p><ul><li>Eclipse: genEclipseRuns</li><li>IDEA: genIntellijRuns</li><li>VSCode: genVSCodeRuns</li></ul><p> 等待一段时间，如果不成功看看java版本是不是1.8.0或者问问百度等，在此处我用的是IDEA，直接在IDEA中选择打开你下载的路径，等待一会后右上角的运行旁应该会有RUNCLIENT标识，进去后记得设置JDK为openjdk-17</p><p> 下面打出一些配置文件，文件里面有详细的介绍，此处就不展开了</p><ul><li>build.gradle</li><li>src&#x2F;main&#x2F;resources&#x2F;META-INF&#x2F;mods.toml</li><li>src&#x2F;main&#x2F;resources&#x2F;pack.mcmeta</li></ul><h2 id="代码框架搭建"><a href="#代码框架搭建" class="headerlink" title="代码框架搭建"></a>代码框架搭建</h2><p> 首先建立包，包名一般为com.游戏名.模组id，我的游戏名是waoa，模组id就命名为examplemod，如果你更改了模组id以及游戏名，可能要修改上面提到的配置文件</p><p> 代码已经放在<a href="https://pan.baidu.com/s/1VTpwHXA6d5AKt7LTlixt1A?pwd=4tn2">这里</a>了，提取码4tn2，下载后覆盖src&#x2F;main，记得改游戏名等，在Item一章才会正式开始编写代码</p><h3 id="代码框架介绍"><a href="#代码框架介绍" class="headerlink" title="代码框架介绍"></a>代码框架介绍</h3><ul><li>ExampleMod: 主类，用来创建Mod实例</li><li>util&#x2F;Reference：配置，用来配置你的modid等信息</li><li>proxy&#x2F;*：代理，其中Client代表客户端代理，Server代表服务端代理</li><li>items&#x2F;ItemBase：用于自定义的Item基类</li><li>handlers&#x2F;RegistryHandler：用于订阅注册事件，注册物品，方块，Registry等</li><li>core&#x2F;*：用于定义Mod内的所有物品，方块，并提供注册函数</li><li>blocks&#x2F;BlockBase：用于自定义的Block基类</li></ul><h3 id="资源介绍"><a href="#资源介绍" class="headerlink" title="资源介绍"></a>资源介绍</h3><p>位于src&#x2F;main&#x2F;resources&#x2F;assets&#x2F;examplemod下（注意examplemod为modid）</p><ul><li>lang&#x2F;*：语言，en_us为英文,zh_cn为中文</li><li>models&#x2F;*：为block和item对应模型</li><li>textures&#x2F;*：为block和item对应材质</li></ul>]]></content>
      
      
      <categories>
          
          <category> 我的世界mod开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的世界mod开发 </tag>
            
            <tag> forge </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
